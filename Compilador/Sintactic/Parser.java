
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615
//----------------------------------------------------

package Compilador.Sintactic;

import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import Compilador.Lexic.Scanner.Token;
import java.io.PrintStream;
import java.util.HashMap;
import Compilador.TSimbols.Taula;
import Compilador.TSimbols.DT.*;
import Compilador.TSimbols.TD.*;
import Compilador.Sintactic.Simbols.*;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return ParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\154\000\002\002\004\000\002\002\004\000\002\002" +
    "\004\000\002\002\003\000\002\003\004\000\002\003\004" +
    "\000\002\003\004\000\002\003\004\000\002\011\004\000" +
    "\002\011\004\000\002\021\004\000\002\021\002\000\002" +
    "\033\003\000\002\033\003\000\002\033\003\000\002\033" +
    "\003\000\002\033\003\000\002\033\003\000\002\033\003" +
    "\000\002\033\004\000\002\033\004\000\002\004\012\000" +
    "\002\004\014\000\002\030\004\000\002\031\007\000\002" +
    "\005\015\000\002\027\003\000\002\027\003\000\002\027" +
    "\003\000\002\027\003\000\002\027\003\000\002\026\003" +
    "\000\002\026\002\000\002\032\005\000\002\032\003\000" +
    "\002\035\004\000\002\022\012\000\002\023\012\000\002" +
    "\037\013\000\002\037\006\000\002\037\002\000\002\025" +
    "\013\000\002\050\016\000\002\050\014\000\002\051\003" +
    "\000\002\051\002\000\002\054\010\000\002\055\006\000" +
    "\002\056\007\000\002\056\004\000\002\010\004\000\002" +
    "\010\006\000\002\020\004\000\002\043\005\000\002\043" +
    "\003\000\002\041\003\000\002\041\003\000\002\041\003" +
    "\000\002\041\003\000\002\042\003\000\002\042\003\000" +
    "\002\042\004\000\002\042\004\000\002\042\004\000\002" +
    "\047\003\000\002\047\005\000\002\034\006\000\002\006" +
    "\007\000\002\046\006\000\002\017\005\000\002\060\004" +
    "\000\002\061\005\000\002\061\005\000\002\061\002\000" +
    "\002\062\004\000\002\063\004\000\002\063\004\000\002" +
    "\063\004\000\002\063\004\000\002\063\004\000\002\063" +
    "\004\000\002\063\002\000\002\064\004\000\002\065\005" +
    "\000\002\065\005\000\002\065\002\000\002\066\004\000" +
    "\002\067\005\000\002\067\005\000\002\067\005\000\002" +
    "\067\002\000\002\057\005\000\002\057\003\000\002\057" +
    "\004\000\002\057\004\000\002\057\003\000\002\057\004" +
    "\000\002\057\004\000\002\057\003\000\002\057\004\000" +
    "\002\057\004\000\002\057\003\000\002\057\003\000\002" +
    "\057\003\000\002\057\006\000\002\057\004\000\002\057" +
    "\004\000\002\057\006" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u0101\000\024\003\017\050\012\051\014\052\006\053" +
    "\010\054\013\055\024\067\011\072\016\001\002\000\004" +
    "\027\u0103\001\002\000\004\002\u0102\001\002\000\006\004" +
    "\uffe5\036\uffe5\001\002\000\004\002\ufffe\001\002\000\006" +
    "\004\uffe4\036\uffe4\001\002\000\020\004\216\050\012\051" +
    "\014\052\006\053\010\054\013\075\215\001\002\000\006" +
    "\004\uffe7\036\uffe7\001\002\000\006\004\uffe3\036\uffe3\001" +
    "\002\000\006\004\uffe6\036\uffe6\001\002\000\024\003\017" +
    "\050\012\051\014\052\006\053\010\054\013\055\024\067" +
    "\011\072\016\001\002\000\016\050\012\051\014\052\006" +
    "\053\010\054\013\055\024\001\002\000\004\027\206\001" +
    "\002\000\004\027\205\001\002\000\024\003\017\050\012" +
    "\051\014\052\006\053\010\054\013\055\024\067\011\072" +
    "\016\001\002\000\004\004\177\001\002\000\004\027\175" +
    "\001\002\000\004\004\025\001\002\000\004\017\026\001" +
    "\002\000\004\020\027\001\002\000\004\021\031\001\002" +
    "\000\004\027\uffbe\001\002\000\004\017\032\001\002\000" +
    "\026\004\045\005\033\006\042\007\040\010\056\011\053" +
    "\012\054\013\047\017\044\047\036\001\002\000\064\003" +
    "\uffa2\012\uffa2\013\uffa2\014\uffa2\015\uffa2\016\uffa2\020\uffa2" +
    "\027\uffa2\036\uffa2\037\uffa2\040\uffa2\041\uffa2\042\uffa2\043" +
    "\uffa2\044\uffa2\045\uffa2\046\uffa2\050\uffa2\051\uffa2\052\uffa2" +
    "\053\uffa2\054\uffa2\055\uffa2\067\uffa2\072\uffa2\001\002\000" +
    "\010\020\uffc8\027\uffc8\036\uffc8\001\002\000\036\003\uffb8" +
    "\020\uffb8\027\uffb8\036\uffb8\045\170\046\166\050\uffb8\051" +
    "\uffb8\052\uffb8\053\uffb8\054\uffb8\055\uffb8\067\uffb8\072\uffb8" +
    "\001\002\000\010\004\161\007\162\017\163\001\002\000" +
    "\010\020\uffc9\027\uffc9\036\uffc9\001\002\000\064\003\uff9a" +
    "\012\uff9a\013\uff9a\014\uff9a\015\uff9a\016\uff9a\020\uff9a\027" +
    "\uff9a\036\uff9a\037\uff9a\040\uff9a\041\uff9a\042\uff9a\043\uff9a" +
    "\044\uff9a\045\uff9a\046\uff9a\050\uff9a\051\uff9a\052\uff9a\053" +
    "\uff9a\054\uff9a\055\uff9a\067\uff9a\072\uff9a\001\002\000\052" +
    "\003\uffb0\020\uffb0\027\uffb0\036\uffb0\037\146\040\144\041" +
    "\145\042\152\043\151\044\150\045\uffb0\046\uffb0\050\uffb0" +
    "\051\uffb0\052\uffb0\053\uffb0\054\uffb0\055\uffb0\067\uffb0\072" +
    "\uffb0\001\002\000\064\003\uffa5\012\uffa5\013\uffa5\014\uffa5" +
    "\015\uffa5\016\uffa5\020\uffa5\027\uffa5\036\uffa5\037\uffa5\040" +
    "\uffa5\041\uffa5\042\uffa5\043\uffa5\044\uffa5\045\uffa5\046\uffa5" +
    "\050\uffa5\051\uffa5\052\uffa5\053\uffa5\054\uffa5\055\uffa5\067" +
    "\uffa5\072\uffa5\001\002\000\056\003\uffac\012\137\013\135" +
    "\020\uffac\027\uffac\036\uffac\037\uffac\040\uffac\041\uffac\042" +
    "\uffac\043\uffac\044\uffac\045\uffac\046\uffac\050\uffac\051\uffac" +
    "\052\uffac\053\uffac\054\uffac\055\uffac\067\uffac\072\uffac\001" +
    "\002\000\026\004\067\005\033\006\042\007\040\010\056" +
    "\011\053\012\054\013\047\017\044\047\036\001\002\000" +
    "\056\012\uff9b\013\uff9b\014\uff9b\015\uff9b\016\uff9b\017\112" +
    "\020\uff9b\021\114\022\107\023\110\024\111\025\113\027" +
    "\uff9b\036\uff9b\037\uff9b\040\uff9b\041\uff9b\042\uff9b\043\uff9b" +
    "\044\uff9b\045\uff9b\046\uff9b\001\002\000\006\020\uffc1\036" +
    "\104\001\002\000\012\005\076\006\077\011\100\017\101" +
    "\001\002\000\064\003\uffa7\012\uffa7\013\uffa7\014\064\015" +
    "\065\016\063\020\uffa7\027\uffa7\036\uffa7\037\uffa7\040\uffa7" +
    "\041\uffa7\042\uffa7\043\uffa7\044\uffa7\045\uffa7\046\uffa7\050" +
    "\uffa7\051\uffa7\052\uffa7\053\uffa7\054\uffa7\055\uffa7\067\uffa7" +
    "\072\uffa7\001\002\000\010\020\uffca\027\uffca\036\uffca\001" +
    "\002\000\010\020\uffc7\027\uffc7\036\uffc7\001\002\000\064" +
    "\003\uff9f\012\uff9f\013\uff9f\014\uff9f\015\uff9f\016\uff9f\020" +
    "\uff9f\027\uff9f\036\uff9f\037\uff9f\040\uff9f\041\uff9f\042\uff9f" +
    "\043\uff9f\044\uff9f\045\uff9f\046\uff9f\050\uff9f\051\uff9f\052" +
    "\uff9f\053\uff9f\054\uff9f\055\uff9f\067\uff9f\072\uff9f\001\002" +
    "\000\010\005\060\006\061\011\062\001\002\000\004\020" +
    "\057\001\002\000\064\003\uff9c\012\uff9c\013\uff9c\014\uff9c" +
    "\015\uff9c\016\uff9c\020\uff9c\027\uff9c\036\uff9c\037\uff9c\040" +
    "\uff9c\041\uff9c\042\uff9c\043\uff9c\044\uff9c\045\uff9c\046\uff9c" +
    "\050\uff9c\051\uff9c\052\uff9c\053\uff9c\054\uff9c\055\uff9c\067" +
    "\uff9c\072\uff9c\001\002\000\004\027\uffbd\001\002\000\064" +
    "\003\uffa1\012\uffa1\013\uffa1\014\uffa1\015\uffa1\016\uffa1\020" +
    "\uffa1\027\uffa1\036\uffa1\037\uffa1\040\uffa1\041\uffa1\042\uffa1" +
    "\043\uffa1\044\uffa1\045\uffa1\046\uffa1\050\uffa1\051\uffa1\052" +
    "\uffa1\053\uffa1\054\uffa1\055\uffa1\067\uffa1\072\uffa1\001\002" +
    "\000\064\003\uffa3\012\uffa3\013\uffa3\014\uffa3\015\uffa3\016" +
    "\uffa3\020\uffa3\027\uffa3\036\uffa3\037\uffa3\040\uffa3\041\uffa3" +
    "\042\uffa3\043\uffa3\044\uffa3\045\uffa3\046\uffa3\050\uffa3\051" +
    "\uffa3\052\uffa3\053\uffa3\054\uffa3\055\uffa3\067\uffa3\072\uffa3" +
    "\001\002\000\064\003\uff9e\012\uff9e\013\uff9e\014\uff9e\015" +
    "\uff9e\016\uff9e\020\uff9e\027\uff9e\036\uff9e\037\uff9e\040\uff9e" +
    "\041\uff9e\042\uff9e\043\uff9e\044\uff9e\045\uff9e\046\uff9e\050" +
    "\uff9e\051\uff9e\052\uff9e\053\uff9e\054\uff9e\055\uff9e\067\uff9e" +
    "\072\uff9e\001\002\000\026\004\067\005\033\006\042\007" +
    "\040\010\056\011\053\012\054\013\047\017\044\047\036" +
    "\001\002\000\026\004\067\005\033\006\042\007\040\010" +
    "\056\011\053\012\054\013\047\017\044\047\036\001\002" +
    "\000\026\004\067\005\033\006\042\007\040\010\056\011" +
    "\053\012\054\013\047\017\044\047\036\001\002\000\056" +
    "\003\uffab\012\uffab\013\uffab\020\uffab\027\uffab\036\uffab\037" +
    "\uffab\040\uffab\041\uffab\042\uffab\043\uffab\044\uffab\045\uffab" +
    "\046\uffab\050\uffab\051\uffab\052\uffab\053\uffab\054\uffab\055" +
    "\uffab\067\uffab\072\uffab\001\002\000\064\003\uff9b\012\uff9b" +
    "\013\uff9b\014\uff9b\015\uff9b\016\uff9b\020\uff9b\027\uff9b\036" +
    "\uff9b\037\uff9b\040\uff9b\041\uff9b\042\uff9b\043\uff9b\044\uff9b" +
    "\045\uff9b\046\uff9b\050\uff9b\051\uff9b\052\uff9b\053\uff9b\054" +
    "\uff9b\055\uff9b\067\uff9b\072\uff9b\001\002\000\064\003\uffa7" +
    "\012\uffa7\013\uffa7\014\064\015\065\016\063\020\uffa7\027" +
    "\uffa7\036\uffa7\037\uffa7\040\uffa7\041\uffa7\042\uffa7\043\uffa7" +
    "\044\uffa7\045\uffa7\046\uffa7\050\uffa7\051\uffa7\052\uffa7\053" +
    "\uffa7\054\uffa7\055\uffa7\067\uffa7\072\uffa7\001\002\000\056" +
    "\003\uffa9\012\uffa9\013\uffa9\020\uffa9\027\uffa9\036\uffa9\037" +
    "\uffa9\040\uffa9\041\uffa9\042\uffa9\043\uffa9\044\uffa9\045\uffa9" +
    "\046\uffa9\050\uffa9\051\uffa9\052\uffa9\053\uffa9\054\uffa9\055" +
    "\uffa9\067\uffa9\072\uffa9\001\002\000\064\003\uffa7\012\uffa7" +
    "\013\uffa7\014\064\015\065\016\063\020\uffa7\027\uffa7\036" +
    "\uffa7\037\uffa7\040\uffa7\041\uffa7\042\uffa7\043\uffa7\044\uffa7" +
    "\045\uffa7\046\uffa7\050\uffa7\051\uffa7\052\uffa7\053\uffa7\054" +
    "\uffa7\055\uffa7\067\uffa7\072\uffa7\001\002\000\056\003\uffaa" +
    "\012\uffaa\013\uffaa\020\uffaa\027\uffaa\036\uffaa\037\uffaa\040" +
    "\uffaa\041\uffaa\042\uffaa\043\uffaa\044\uffaa\045\uffaa\046\uffaa" +
    "\050\uffaa\051\uffaa\052\uffaa\053\uffaa\054\uffaa\055\uffaa\067" +
    "\uffaa\072\uffaa\001\002\000\064\003\uffa7\012\uffa7\013\uffa7" +
    "\014\064\015\065\016\063\020\uffa7\027\uffa7\036\uffa7\037" +
    "\uffa7\040\uffa7\041\uffa7\042\uffa7\043\uffa7\044\uffa7\045\uffa7" +
    "\046\uffa7\050\uffa7\051\uffa7\052\uffa7\053\uffa7\054\uffa7\055" +
    "\uffa7\067\uffa7\072\uffa7\001\002\000\056\003\uffa8\012\uffa8" +
    "\013\uffa8\020\uffa8\027\uffa8\036\uffa8\037\uffa8\040\uffa8\041" +
    "\uffa8\042\uffa8\043\uffa8\044\uffa8\045\uffa8\046\uffa8\050\uffa8" +
    "\051\uffa8\052\uffa8\053\uffa8\054\uffa8\055\uffa8\067\uffa8\072" +
    "\uffa8\001\002\000\064\003\uffa0\012\uffa0\013\uffa0\014\uffa0" +
    "\015\uffa0\016\uffa0\020\uffa0\027\uffa0\036\uffa0\037\uffa0\040" +
    "\uffa0\041\uffa0\042\uffa0\043\uffa0\044\uffa0\045\uffa0\046\uffa0" +
    "\050\uffa0\051\uffa0\052\uffa0\053\uffa0\054\uffa0\055\uffa0\067" +
    "\uffa0\072\uffa0\001\002\000\064\003\uffa4\012\uffa4\013\uffa4" +
    "\014\uffa4\015\uffa4\016\uffa4\020\uffa4\027\uffa4\036\uffa4\037" +
    "\uffa4\040\uffa4\041\uffa4\042\uffa4\043\uffa4\044\uffa4\045\uffa4" +
    "\046\uffa4\050\uffa4\051\uffa4\052\uffa4\053\uffa4\054\uffa4\055" +
    "\uffa4\067\uffa4\072\uffa4\001\002\000\064\003\uff9d\012\uff9d" +
    "\013\uff9d\014\uff9d\015\uff9d\016\uff9d\020\uff9d\027\uff9d\036" +
    "\uff9d\037\uff9d\040\uff9d\041\uff9d\042\uff9d\043\uff9d\044\uff9d" +
    "\045\uff9d\046\uff9d\050\uff9d\051\uff9d\052\uff9d\053\uff9d\054" +
    "\uff9d\055\uff9d\067\uff9d\072\uff9d\001\002\000\026\004\067" +
    "\005\033\006\042\007\040\010\056\011\053\012\054\013" +
    "\047\017\044\047\036\001\002\000\004\020\103\001\002" +
    "\000\064\003\uff99\012\uff99\013\uff99\014\uff99\015\uff99\016" +
    "\uff99\020\uff99\027\uff99\036\uff99\037\uff99\040\uff99\041\uff99" +
    "\042\uff99\043\uff99\044\uff99\045\uff99\046\uff99\050\uff99\051" +
    "\uff99\052\uff99\053\uff99\054\uff99\055\uff99\067\uff99\072\uff99" +
    "\001\002\000\026\004\045\005\033\006\042\007\040\010" +
    "\056\011\053\012\054\013\047\017\044\047\036\001\002" +
    "\000\004\020\uffc0\001\002\000\010\020\uffcd\027\uffcd\036" +
    "\uffcd\001\002\000\010\020\uffc6\027\uffc6\036\uffc6\001\002" +
    "\000\010\020\uffc5\027\uffc5\036\uffc5\001\002\000\026\004" +
    "\067\005\033\006\042\007\040\010\056\011\053\012\054" +
    "\013\047\017\044\047\036\001\002\000\020\006\121\020" +
    "\uffe1\050\012\051\014\052\006\053\010\054\013\001\002" +
    "\000\026\004\067\005\033\006\042\007\040\010\056\011" +
    "\053\012\054\013\047\017\044\047\036\001\002\000\026" +
    "\004\045\005\033\006\042\007\040\010\056\011\053\012" +
    "\054\013\047\017\044\047\036\001\002\000\010\020\uffc2" +
    "\027\uffc2\036\uffc2\001\002\000\010\020\uffc3\027\uffc3\036" +
    "\uffc3\001\002\000\006\020\uffdf\036\130\001\002\000\004" +
    "\020\126\001\002\000\004\020\125\001\002\000\004\004" +
    "\124\001\002\000\004\020\uffe2\001\002\000\006\020\uffde" +
    "\036\uffde\001\002\000\010\020\uffbf\027\uffbf\036\uffbf\001" +
    "\002\000\004\027\127\001\002\000\050\003\uffe9\004\uffe9" +
    "\020\uffe9\027\uffe9\034\uffe9\036\uffe9\050\uffe9\051\uffe9\052" +
    "\uffe9\053\uffe9\054\uffe9\055\uffe9\056\uffe9\064\uffe9\065\uffe9" +
    "\066\uffe9\072\uffe9\073\uffe9\074\uffe9\001\002\000\014\050" +
    "\012\051\014\052\006\053\010\054\013\001\002\000\004" +
    "\020\uffe0\001\002\000\010\020\uffc4\027\uffc4\036\uffc4\001" +
    "\002\000\004\020\134\001\002\000\064\003\uffa6\012\uffa6" +
    "\013\uffa6\014\uffa6\015\uffa6\016\uffa6\020\uffa6\027\uffa6\036" +
    "\uffa6\037\uffa6\040\uffa6\041\uffa6\042\uffa6\043\uffa6\044\uffa6" +
    "\045\uffa6\046\uffa6\050\uffa6\051\uffa6\052\uffa6\053\uffa6\054" +
    "\uffa6\055\uffa6\067\uffa6\072\uffa6\001\002\000\026\004\067" +
    "\005\033\006\042\007\040\010\056\011\053\012\054\013" +
    "\047\017\044\047\036\001\002\000\052\003\uffaf\020\uffaf" +
    "\027\uffaf\036\uffaf\037\uffaf\040\uffaf\041\uffaf\042\uffaf\043" +
    "\uffaf\044\uffaf\045\uffaf\046\uffaf\050\uffaf\051\uffaf\052\uffaf" +
    "\053\uffaf\054\uffaf\055\uffaf\067\uffaf\072\uffaf\001\002\000" +
    "\026\004\067\005\033\006\042\007\040\010\056\011\053" +
    "\012\054\013\047\017\044\047\036\001\002\000\056\003" +
    "\uffac\012\137\013\135\020\uffac\027\uffac\036\uffac\037\uffac" +
    "\040\uffac\041\uffac\042\uffac\043\uffac\044\uffac\045\uffac\046" +
    "\uffac\050\uffac\051\uffac\052\uffac\053\uffac\054\uffac\055\uffac" +
    "\067\uffac\072\uffac\001\002\000\052\003\uffae\020\uffae\027" +
    "\uffae\036\uffae\037\uffae\040\uffae\041\uffae\042\uffae\043\uffae" +
    "\044\uffae\045\uffae\046\uffae\050\uffae\051\uffae\052\uffae\053" +
    "\uffae\054\uffae\055\uffae\067\uffae\072\uffae\001\002\000\056" +
    "\003\uffac\012\137\013\135\020\uffac\027\uffac\036\uffac\037" +
    "\uffac\040\uffac\041\uffac\042\uffac\043\uffac\044\uffac\045\uffac" +
    "\046\uffac\050\uffac\051\uffac\052\uffac\053\uffac\054\uffac\055" +
    "\uffac\067\uffac\072\uffac\001\002\000\052\003\uffad\020\uffad" +
    "\027\uffad\036\uffad\037\uffad\040\uffad\041\uffad\042\uffad\043" +
    "\uffad\044\uffad\045\uffad\046\uffad\050\uffad\051\uffad\052\uffad" +
    "\053\uffad\054\uffad\055\uffad\067\uffad\072\uffad\001\002\000" +
    "\026\004\067\005\033\006\042\007\040\010\056\011\053" +
    "\012\054\013\047\017\044\047\036\001\002\000\026\004" +
    "\067\005\033\006\042\007\040\010\056\011\053\012\054" +
    "\013\047\017\044\047\036\001\002\000\026\004\067\005" +
    "\033\006\042\007\040\010\056\011\053\012\054\013\047" +
    "\017\044\047\036\001\002\000\036\003\uffb7\020\uffb7\027" +
    "\uffb7\036\uffb7\045\uffb7\046\uffb7\050\uffb7\051\uffb7\052\uffb7" +
    "\053\uffb7\054\uffb7\055\uffb7\067\uffb7\072\uffb7\001\002\000" +
    "\026\004\067\005\033\006\042\007\040\010\056\011\053" +
    "\012\054\013\047\017\044\047\036\001\002\000\026\004" +
    "\067\005\033\006\042\007\040\010\056\011\053\012\054" +
    "\013\047\017\044\047\036\001\002\000\026\004\067\005" +
    "\033\006\042\007\040\010\056\011\053\012\054\013\047" +
    "\017\044\047\036\001\002\000\036\003\uffb1\020\uffb1\027" +
    "\uffb1\036\uffb1\045\uffb1\046\uffb1\050\uffb1\051\uffb1\052\uffb1" +
    "\053\uffb1\054\uffb1\055\uffb1\067\uffb1\072\uffb1\001\002\000" +
    "\036\003\uffb4\020\uffb4\027\uffb4\036\uffb4\045\uffb4\046\uffb4" +
    "\050\uffb4\051\uffb4\052\uffb4\053\uffb4\054\uffb4\055\uffb4\067" +
    "\uffb4\072\uffb4\001\002\000\036\003\uffb3\020\uffb3\027\uffb3" +
    "\036\uffb3\045\uffb3\046\uffb3\050\uffb3\051\uffb3\052\uffb3\053" +
    "\uffb3\054\uffb3\055\uffb3\067\uffb3\072\uffb3\001\002\000\036" +
    "\003\uffb5\020\uffb5\027\uffb5\036\uffb5\045\uffb5\046\uffb5\050" +
    "\uffb5\051\uffb5\052\uffb5\053\uffb5\054\uffb5\055\uffb5\067\uffb5" +
    "\072\uffb5\001\002\000\036\003\uffb2\020\uffb2\027\uffb2\036" +
    "\uffb2\045\uffb2\046\uffb2\050\uffb2\051\uffb2\052\uffb2\053\uffb2" +
    "\054\uffb2\055\uffb2\067\uffb2\072\uffb2\001\002\000\036\003" +
    "\uffb6\020\uffb6\027\uffb6\036\uffb6\045\uffb6\046\uffb6\050\uffb6" +
    "\051\uffb6\052\uffb6\053\uffb6\054\uffb6\055\uffb6\067\uffb6\072" +
    "\uffb6\001\002\000\064\003\uff97\012\uff97\013\uff97\014\uff97" +
    "\015\uff97\016\uff97\020\uff97\027\uff97\036\uff97\037\uff97\040" +
    "\uff97\041\uff97\042\uff97\043\uff97\044\uff97\045\uff97\046\uff97" +
    "\050\uff97\051\uff97\052\uff97\053\uff97\054\uff97\055\uff97\067" +
    "\uff97\072\uff97\001\002\000\064\003\uff98\012\uff98\013\uff98" +
    "\014\uff98\015\uff98\016\uff98\020\uff98\027\uff98\036\uff98\037" +
    "\uff98\040\uff98\041\uff98\042\uff98\043\uff98\044\uff98\045\uff98" +
    "\046\uff98\050\uff98\051\uff98\052\uff98\053\uff98\054\uff98\055" +
    "\uff98\067\uff98\072\uff98\001\002\000\026\004\067\005\033" +
    "\006\042\007\040\010\056\011\053\012\054\013\047\017" +
    "\044\047\036\001\002\000\004\020\165\001\002\000\064" +
    "\003\uff96\012\uff96\013\uff96\014\uff96\015\uff96\016\uff96\020" +
    "\uff96\027\uff96\036\uff96\037\uff96\040\uff96\041\uff96\042\uff96" +
    "\043\uff96\044\uff96\045\uff96\046\uff96\050\uff96\051\uff96\052" +
    "\uff96\053\uff96\054\uff96\055\uff96\067\uff96\072\uff96\001\002" +
    "\000\026\004\067\005\033\006\042\007\040\010\056\011" +
    "\053\012\054\013\047\017\044\047\036\001\002\000\032" +
    "\003\uffbb\020\uffbb\027\uffbb\036\uffbb\050\uffbb\051\uffbb\052" +
    "\uffbb\053\uffbb\054\uffbb\055\uffbb\067\uffbb\072\uffbb\001\002" +
    "\000\026\004\067\005\033\006\042\007\040\010\056\011" +
    "\053\012\054\013\047\017\044\047\036\001\002\000\036" +
    "\003\uffb8\020\uffb8\027\uffb8\036\uffb8\045\170\046\166\050" +
    "\uffb8\051\uffb8\052\uffb8\053\uffb8\054\uffb8\055\uffb8\067\uffb8" +
    "\072\uffb8\001\002\000\032\003\uffb9\020\uffb9\027\uffb9\036" +
    "\uffb9\050\uffb9\051\uffb9\052\uffb9\053\uffb9\054\uffb9\055\uffb9" +
    "\067\uffb9\072\uffb9\001\002\000\036\003\uffb8\020\uffb8\027" +
    "\uffb8\036\uffb8\045\170\046\166\050\uffb8\051\uffb8\052\uffb8" +
    "\053\uffb8\054\uffb8\055\uffb8\067\uffb8\072\uffb8\001\002\000" +
    "\032\003\uffba\020\uffba\027\uffba\036\uffba\050\uffba\051\uffba" +
    "\052\uffba\053\uffba\054\uffba\055\uffba\067\uffba\072\uffba\001" +
    "\002\000\044\003\ufffc\004\ufffc\034\ufffc\050\ufffc\051\ufffc" +
    "\052\ufffc\053\ufffc\054\ufffc\055\ufffc\056\ufffc\064\ufffc\065" +
    "\ufffc\066\ufffc\067\ufffc\072\ufffc\073\ufffc\074\ufffc\001\002" +
    "\000\006\021\202\027\uffcf\001\002\000\010\021\uffcb\027" +
    "\uffcb\036\200\001\002\000\004\004\177\001\002\000\006" +
    "\021\uffcc\027\uffcc\001\002\000\026\004\045\005\033\006" +
    "\042\007\040\010\056\011\053\012\054\013\047\017\044" +
    "\047\036\001\002\000\004\027\uffce\001\002\000\004\002" +
    "\uffff\001\002\000\044\003\ufffd\004\ufffd\034\ufffd\050\ufffd" +
    "\051\ufffd\052\ufffd\053\ufffd\054\ufffd\055\ufffd\056\ufffd\064" +
    "\ufffd\065\ufffd\066\ufffd\067\ufffd\072\ufffd\073\ufffd\074\ufffd" +
    "\001\002\000\044\003\ufffa\004\ufffa\034\ufffa\050\ufffa\051" +
    "\ufffa\052\ufffa\053\ufffa\054\ufffa\055\ufffa\056\ufffa\064\ufffa" +
    "\065\ufffa\066\ufffa\067\ufffa\072\ufffa\073\ufffa\074\ufffa\001" +
    "\002\000\004\004\177\001\002\000\004\027\uffd0\001\002" +
    "\000\004\021\212\001\002\000\026\004\045\005\033\006" +
    "\042\007\040\010\056\011\053\012\054\013\047\017\044" +
    "\047\036\001\002\000\004\027\uffd1\001\002\000\004\002" +
    "\000\001\002\000\004\017\371\001\002\000\004\017\363" +
    "\001\002\000\004\004\220\001\002\000\004\017\221\001" +
    "\002\000\016\020\uffe1\050\012\051\014\052\006\053\010" +
    "\054\013\001\002\000\004\020\223\001\002\000\004\033" +
    "\224\001\002\000\042\003\017\004\235\034\ufff6\050\012" +
    "\051\014\052\006\053\010\054\013\055\024\056\246\064" +
    "\250\065\234\066\247\072\016\073\236\074\225\001\002" +
    "\000\004\017\360\001\002\000\004\027\357\001\002\000" +
    "\042\003\ufff4\004\ufff4\034\ufff4\050\ufff4\051\ufff4\052\ufff4" +
    "\053\ufff4\054\ufff4\055\ufff4\056\ufff4\064\ufff4\065\ufff4\066" +
    "\ufff4\072\ufff4\073\ufff4\074\ufff4\001\002\000\042\003\017" +
    "\004\235\034\ufff6\050\012\051\014\052\006\053\010\054" +
    "\013\055\024\056\246\064\250\065\234\066\247\072\016" +
    "\073\236\074\225\001\002\000\042\003\ufff1\004\ufff1\034" +
    "\ufff1\050\ufff1\051\ufff1\052\ufff1\053\ufff1\054\ufff1\055\ufff1" +
    "\056\ufff1\064\ufff1\065\ufff1\066\ufff1\072\ufff1\073\ufff1\074" +
    "\ufff1\001\002\000\004\027\355\001\002\000\042\003\ufff3" +
    "\004\ufff3\034\ufff3\050\ufff3\051\ufff3\052\ufff3\053\ufff3\054" +
    "\ufff3\055\ufff3\056\ufff3\064\ufff3\065\ufff3\066\ufff3\072\ufff3" +
    "\073\ufff3\074\ufff3\001\002\000\004\033\345\001\002\000" +
    "\016\017\342\021\343\022\107\023\110\024\111\025\113" +
    "\001\002\000\004\017\335\001\002\000\004\027\334\001" +
    "\002\000\042\003\ufff5\004\ufff5\034\ufff5\050\ufff5\051\ufff5" +
    "\052\ufff5\053\ufff5\054\ufff5\055\ufff5\056\ufff5\064\ufff5\065" +
    "\ufff5\066\ufff5\072\ufff5\073\ufff5\074\ufff5\001\002\000\042" +
    "\003\ufff0\004\ufff0\034\ufff0\050\ufff0\051\ufff0\052\ufff0\053" +
    "\ufff0\054\ufff0\055\ufff0\056\ufff0\064\ufff0\065\ufff0\066\ufff0" +
    "\072\ufff0\073\ufff0\074\ufff0\001\002\000\004\034\330\001" +
    "\002\000\004\027\327\001\002\000\042\003\uffef\004\uffef" +
    "\034\uffef\050\uffef\051\uffef\052\uffef\053\uffef\054\uffef\055" +
    "\uffef\056\uffef\064\uffef\065\uffef\066\uffef\072\uffef\073\uffef" +
    "\074\uffef\001\002\000\042\003\ufff2\004\ufff2\034\ufff2\050" +
    "\ufff2\051\ufff2\052\ufff2\053\ufff2\054\ufff2\055\ufff2\056\ufff2" +
    "\064\ufff2\065\ufff2\066\ufff2\072\ufff2\073\ufff2\074\ufff2\001" +
    "\002\000\004\017\304\001\002\000\004\017\260\001\002" +
    "\000\004\017\251\001\002\000\026\004\067\005\033\006" +
    "\042\007\040\010\056\011\053\012\054\013\047\017\044" +
    "\047\036\001\002\000\004\020\253\001\002\000\004\065" +
    "\254\001\002\000\004\033\255\001\002\000\042\003\017" +
    "\004\235\034\ufff6\050\012\051\014\052\006\053\010\054" +
    "\013\055\024\056\246\064\250\065\234\066\247\072\016" +
    "\073\236\074\225\001\002\000\004\034\257\001\002\000" +
    "\042\003\uffdd\004\uffdd\034\uffdd\050\uffdd\051\uffdd\052\uffdd" +
    "\053\uffdd\054\uffdd\055\uffdd\056\uffdd\064\uffdd\065\uffdd\066" +
    "\uffdd\072\uffdd\073\uffdd\074\uffdd\001\002\000\016\027\261" +
    "\050\012\051\014\052\006\053\010\054\013\001\002\000" +
    "\030\004\067\005\033\006\042\007\040\010\056\011\053" +
    "\012\054\013\047\017\044\027\uffd4\047\036\001\002\000" +
    "\004\004\177\001\002\000\004\027\264\001\002\000\030" +
    "\004\067\005\033\006\042\007\040\010\056\011\053\012" +
    "\054\013\047\017\044\027\uffd4\047\036\001\002\000\004" +
    "\027\267\001\002\000\006\020\uffd5\027\uffd5\001\002\000" +
    "\030\004\067\005\033\006\042\007\040\010\056\011\053" +
    "\012\054\013\047\017\044\020\uffd4\047\036\001\002\000" +
    "\004\020\271\001\002\000\004\033\272\001\002\000\040" +
    "\003\017\004\235\050\012\051\014\052\006\053\010\054" +
    "\013\055\024\056\246\064\250\065\234\066\247\072\016" +
    "\073\236\074\225\001\002\000\004\034\274\001\002\000" +
    "\042\003\uffd7\004\uffd7\034\uffd7\050\uffd7\051\uffd7\052\uffd7" +
    "\053\uffd7\054\uffd7\055\uffd7\056\uffd7\064\uffd7\065\uffd7\066" +
    "\uffd7\072\uffd7\073\uffd7\074\uffd7\001\002\000\004\027\276" +
    "\001\002\000\030\004\067\005\033\006\042\007\040\010" +
    "\056\011\053\012\054\013\047\017\044\020\uffd4\047\036" +
    "\001\002\000\004\020\300\001\002\000\004\033\301\001" +
    "\002\000\040\003\017\004\235\050\012\051\014\052\006" +
    "\053\010\054\013\055\024\056\246\064\250\065\234\066" +
    "\247\072\016\073\236\074\225\001\002\000\004\034\303" +
    "\001\002\000\042\003\uffd6\004\uffd6\034\uffd6\050\uffd6\051" +
    "\uffd6\052\uffd6\053\uffd6\054\uffd6\055\uffd6\056\uffd6\064\uffd6" +
    "\065\uffd6\066\uffd6\072\uffd6\073\uffd6\074\uffd6\001\002\000" +
    "\026\004\067\005\033\006\042\007\040\010\056\011\053" +
    "\012\054\013\047\017\044\047\036\001\002\000\004\020" +
    "\306\001\002\000\004\033\307\001\002\000\042\003\017" +
    "\004\235\034\ufff6\050\012\051\014\052\006\053\010\054" +
    "\013\055\024\056\246\064\250\065\234\066\247\072\016" +
    "\073\236\074\225\001\002\000\004\034\311\001\002\000" +
    "\044\003\uffd9\004\uffd9\034\uffd9\050\uffd9\051\uffd9\052\uffd9" +
    "\053\uffd9\054\uffd9\055\uffd9\056\uffd9\057\312\064\uffd9\065" +
    "\uffd9\066\uffd9\072\uffd9\073\uffd9\074\uffd9\001\002\000\006" +
    "\033\315\056\314\001\002\000\042\003\uffdc\004\uffdc\034" +
    "\uffdc\050\uffdc\051\uffdc\052\uffdc\053\uffdc\054\uffdc\055\uffdc" +
    "\056\uffdc\064\uffdc\065\uffdc\066\uffdc\072\uffdc\073\uffdc\074" +
    "\uffdc\001\002\000\004\017\320\001\002\000\042\003\017" +
    "\004\235\034\ufff6\050\012\051\014\052\006\053\010\054" +
    "\013\055\024\056\246\064\250\065\234\066\247\072\016" +
    "\073\236\074\225\001\002\000\004\034\317\001\002\000" +
    "\042\003\uffda\004\uffda\034\uffda\050\uffda\051\uffda\052\uffda" +
    "\053\uffda\054\uffda\055\uffda\056\uffda\064\uffda\065\uffda\066" +
    "\uffda\072\uffda\073\uffda\074\uffda\001\002\000\026\004\067" +
    "\005\033\006\042\007\040\010\056\011\053\012\054\013" +
    "\047\017\044\047\036\001\002\000\004\020\322\001\002" +
    "\000\004\033\323\001\002\000\042\003\017\004\235\034" +
    "\ufff6\050\012\051\014\052\006\053\010\054\013\055\024" +
    "\056\246\064\250\065\234\066\247\072\016\073\236\074" +
    "\225\001\002\000\004\034\325\001\002\000\044\003\uffd9" +
    "\004\uffd9\034\uffd9\050\uffd9\051\uffd9\052\uffd9\053\uffd9\054" +
    "\uffd9\055\uffd9\056\uffd9\057\312\064\uffd9\065\uffd9\066\uffd9" +
    "\072\uffd9\073\uffd9\074\uffd9\001\002\000\042\003\uffdb\004" +
    "\uffdb\034\uffdb\050\uffdb\051\uffdb\052\uffdb\053\uffdb\054\uffdb" +
    "\055\uffdb\056\uffdb\064\uffdb\065\uffdb\066\uffdb\072\uffdb\073" +
    "\uffdb\074\uffdb\001\002\000\042\003\ufff9\004\ufff9\034\ufff9" +
    "\050\ufff9\051\ufff9\052\ufff9\053\ufff9\054\ufff9\055\ufff9\056" +
    "\ufff9\064\ufff9\065\ufff9\066\ufff9\072\ufff9\073\ufff9\074\ufff9" +
    "\001\002\000\004\070\332\001\002\000\024\003\uffeb\050" +
    "\uffeb\051\uffeb\052\uffeb\053\uffeb\054\uffeb\055\uffeb\067\uffeb" +
    "\072\uffeb\001\002\000\026\004\067\005\033\006\042\007" +
    "\040\010\056\011\053\012\054\013\047\017\044\047\036" +
    "\001\002\000\024\003\uffea\050\uffea\051\uffea\052\uffea\053" +
    "\uffea\054\uffea\055\uffea\067\uffea\072\uffea\001\002\000\042" +
    "\003\uffed\004\uffed\034\uffed\050\uffed\051\uffed\052\uffed\053" +
    "\uffed\054\uffed\055\uffed\056\uffed\064\uffed\065\uffed\066\uffed" +
    "\072\uffed\073\uffed\074\uffed\001\002\000\014\050\012\051" +
    "\014\052\006\053\010\054\013\001\002\000\004\036\337" +
    "\001\002\000\004\004\340\001\002\000\004\020\341\001" +
    "\002\000\004\027\uffd3\001\002\000\016\020\uffe1\050\012" +
    "\051\014\052\006\053\010\054\013\001\002\000\030\004" +
    "\045\005\033\006\042\007\040\010\056\011\053\012\054" +
    "\013\047\017\044\021\031\047\036\001\002\000\004\027" +
    "\uffbc\001\002\000\042\003\017\004\235\034\ufff6\050\012" +
    "\051\014\052\006\053\010\054\013\055\024\056\246\064" +
    "\250\065\234\066\247\072\016\073\236\074\225\001\002" +
    "\000\004\034\347\001\002\000\004\064\350\001\002\000" +
    "\004\017\351\001\002\000\002\001\002\000\004\020\353" +
    "\001\002\000\004\027\354\001\002\000\042\003\uffd8\004" +
    "\uffd8\034\uffd8\050\uffd8\051\uffd8\052\uffd8\053\uffd8\054\uffd8" +
    "\055\uffd8\056\uffd8\064\uffd8\065\uffd8\066\uffd8\072\uffd8\073" +
    "\uffd8\074\uffd8\001\002\000\042\003\uffee\004\uffee\034\uffee" +
    "\050\uffee\051\uffee\052\uffee\053\uffee\054\uffee\055\uffee\056" +
    "\uffee\064\uffee\065\uffee\066\uffee\072\uffee\073\uffee\074\uffee" +
    "\001\002\000\004\034\ufff7\001\002\000\042\003\ufff8\004" +
    "\ufff8\034\ufff8\050\ufff8\051\ufff8\052\ufff8\053\ufff8\054\ufff8" +
    "\055\ufff8\056\ufff8\064\ufff8\065\ufff8\066\ufff8\072\ufff8\073" +
    "\ufff8\074\ufff8\001\002\000\026\004\067\005\033\006\042" +
    "\007\040\010\056\011\053\012\054\013\047\017\044\047" +
    "\036\001\002\000\004\020\362\001\002\000\004\027\uffd2" +
    "\001\002\000\016\020\uffe1\050\012\051\014\052\006\053" +
    "\010\054\013\001\002\000\004\020\365\001\002\000\004" +
    "\033\366\001\002\000\042\003\017\004\235\034\ufff6\050" +
    "\012\051\014\052\006\053\010\054\013\055\024\056\246" +
    "\064\250\065\234\066\247\072\016\073\236\074\225\001" +
    "\002\000\004\034\370\001\002\000\024\003\uffec\050\uffec" +
    "\051\uffec\052\uffec\053\uffec\054\uffec\055\uffec\067\uffec\072" +
    "\uffec\001\002\000\004\053\372\001\002\000\004\004\373" +
    "\001\002\000\004\031\374\001\002\000\004\032\375\001" +
    "\002\000\004\020\376\001\002\000\004\033\377\001\002" +
    "\000\042\003\017\004\235\034\ufff6\050\012\051\014\052" +
    "\006\053\010\054\013\055\024\056\246\064\250\065\234" +
    "\066\247\072\016\073\236\074\225\001\002\000\004\034" +
    "\u0101\001\002\000\004\002\uffe8\001\002\000\004\002\001" +
    "\001\002\000\044\003\ufffb\004\ufffb\034\ufffb\050\ufffb\051" +
    "\ufffb\052\ufffb\053\ufffb\054\ufffb\055\ufffb\056\ufffb\064\ufffb" +
    "\065\ufffb\066\ufffb\067\ufffb\072\ufffb\073\ufffb\074\ufffb\001" +
    "\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u0101\000\022\002\004\003\014\004\020\005\006\006" +
    "\017\010\022\027\021\056\003\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\027\216\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\022\002\213\003" +
    "\014\004\020\005\006\006\017\010\022\027\021\056\003" +
    "\001\001\000\006\006\207\027\206\001\001\000\002\001" +
    "\001\000\002\001\001\000\022\002\203\003\014\004\020" +
    "\005\006\006\017\010\022\027\021\056\003\001\001\000" +
    "\004\043\175\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\046\027\001" +
    "\001\000\002\001\001\000\002\001\001\000\026\020\036" +
    "\031\051\034\033\041\045\047\054\057\047\060\050\062" +
    "\034\064\040\066\042\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\061\166\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\063\146\001\001" +
    "\000\002\001\001\000\004\065\135\001\001\000\014\057" +
    "\047\060\132\062\034\064\040\066\042\001\001\000\004" +
    "\042\105\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\067\065\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\057\073\001\001\000" +
    "\004\057\071\001\001\000\004\057\067\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\067\070\001\001\000" +
    "\002\001\001\000\004\067\072\001\001\000\002\001\001" +
    "\000\004\067\074\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\057\047" +
    "\060\101\062\034\064\040\066\042\001\001\000\002\001" +
    "\001\000\002\001\001\000\026\020\036\031\051\034\033" +
    "\041\045\047\104\057\047\060\050\062\034\064\040\066" +
    "\042\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\057\047\060\131\062" +
    "\034\064\040\066\042\001\001\000\012\026\117\027\121" +
    "\032\122\035\116\001\001\000\014\057\047\060\115\062" +
    "\034\064\040\066\042\001\001\000\024\020\036\031\051" +
    "\034\033\041\114\057\047\060\050\062\034\064\040\066" +
    "\042\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\027\121\032" +
    "\130\035\116\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\057\047\066" +
    "\141\001\001\000\002\001\001\000\006\057\047\066\137" +
    "\001\001\000\004\065\140\001\001\000\002\001\001\000" +
    "\004\065\142\001\001\000\002\001\001\000\010\057\047" +
    "\064\157\066\042\001\001\000\010\057\047\064\156\066" +
    "\042\001\001\000\010\057\047\064\155\066\042\001\001" +
    "\000\002\001\001\000\010\057\047\064\154\066\042\001" +
    "\001\000\010\057\047\064\153\066\042\001\001\000\010" +
    "\057\047\064\152\066\042\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\057\047\060\163\062\034\064\040\066\042" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\057" +
    "\047\062\172\064\040\066\042\001\001\000\002\001\001" +
    "\000\012\057\047\062\170\064\040\066\042\001\001\000" +
    "\004\061\171\001\001\000\002\001\001\000\004\061\173" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\043\200\001\001\000\002" +
    "\001\001\000\024\020\036\031\051\034\033\041\202\057" +
    "\047\060\050\062\034\064\040\066\042\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\043\210\001\001\000\002\001\001\000\002" +
    "\001\001\000\024\020\036\031\051\034\033\041\212\057" +
    "\047\060\050\062\034\064\040\066\042\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\026\221" +
    "\027\121\032\122\035\116\001\001\000\002\001\001\000" +
    "\002\001\001\000\044\003\237\006\017\010\022\011\226" +
    "\017\242\020\225\021\241\022\232\023\230\025\244\027" +
    "\021\031\240\033\227\050\243\054\231\055\236\056\003" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\044\003\237\006\017\010\022\011\226\017\242" +
    "\020\225\021\355\022\232\023\230\025\244\027\021\031" +
    "\240\033\227\050\243\054\231\055\236\056\003\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\042\105\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\057\047\060\251\062\034\064\040\066\042" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\044\003\237\006\017\010\022\011\226\017\242" +
    "\020\225\021\255\022\232\023\230\025\244\027\021\031" +
    "\240\033\227\050\243\054\231\055\236\056\003\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\027\261\001" +
    "\001\000\016\051\274\057\047\060\265\062\034\064\040" +
    "\066\042\001\001\000\004\043\262\001\001\000\002\001" +
    "\001\000\016\051\264\057\047\060\265\062\034\064\040" +
    "\066\042\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\051\267\057\047\060\265\062\034\064\040\066\042" +
    "\001\001\000\002\001\001\000\002\001\001\000\042\003" +
    "\237\006\017\010\022\011\226\017\242\020\225\022\232" +
    "\023\230\025\244\027\021\031\240\033\272\050\243\054" +
    "\231\055\236\056\003\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\051\276\057\047\060" +
    "\265\062\034\064\040\066\042\001\001\000\002\001\001" +
    "\000\002\001\001\000\042\003\237\006\017\010\022\011" +
    "\226\017\242\020\225\022\232\023\230\025\244\027\021" +
    "\031\240\033\301\050\243\054\231\055\236\056\003\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\057\047" +
    "\060\304\062\034\064\040\066\042\001\001\000\002\001" +
    "\001\000\002\001\001\000\044\003\237\006\017\010\022" +
    "\011\226\017\242\020\225\021\307\022\232\023\230\025" +
    "\244\027\021\031\240\033\227\050\243\054\231\055\236" +
    "\056\003\001\001\000\002\001\001\000\004\037\312\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\044\003\237\006\017\010\022\011\226\017\242\020" +
    "\225\021\315\022\232\023\230\025\244\027\021\031\240" +
    "\033\227\050\243\054\231\055\236\056\003\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\057\047\060\320" +
    "\062\034\064\040\066\042\001\001\000\002\001\001\000" +
    "\002\001\001\000\044\003\237\006\017\010\022\011\226" +
    "\017\242\020\225\021\323\022\232\023\230\025\244\027" +
    "\021\031\240\033\227\050\243\054\231\055\236\056\003" +
    "\001\001\000\002\001\001\000\004\037\325\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\030\330\001\001" +
    "\000\002\001\001\000\014\057\047\060\332\062\034\064" +
    "\040\066\042\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\027\335\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\026\117" +
    "\027\121\032\122\035\116\001\001\000\026\020\036\031" +
    "\051\034\033\041\114\046\343\057\047\060\050\062\034" +
    "\064\040\066\042\001\001\000\002\001\001\000\044\003" +
    "\237\006\017\010\022\011\226\017\242\020\225\021\345" +
    "\022\232\023\230\025\244\027\021\031\240\033\227\050" +
    "\243\054\231\055\236\056\003\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\036\351\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\057\047\060\360\062\034\064\040\066\042\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\026\363\027" +
    "\121\032\122\035\116\001\001\000\002\001\001\000\002" +
    "\001\001\000\044\003\237\006\017\010\022\011\226\017" +
    "\242\020\225\021\366\022\232\023\230\025\244\027\021" +
    "\031\240\033\227\050\243\054\231\055\236\056\003\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\044\003\237\006\017" +
    "\010\022\011\226\017\242\020\225\021\377\022\232\023" +
    "\230\025\244\027\021\031\240\033\227\050\243\054\231" +
    "\055\236\056\003\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    /**********************************************************************
     *             Creació i Gestió de la Taula de Simbols                *
     **********************************************************************/

    Taula taula_simbols = new Taula();

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    private boolean errorSemantic = false;

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_error("Error sintàctic catastròfic", cur_token);
        done_parsing();        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("de sintaxis", cur_token);
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    public void report_error_semantic(String message,Location left, Location right){
        System.err.println("ERROR "+message+" desde: "+left.getLine()+"/"+left.getColumn()+" fins: "+right.getLine()+"/"+right.getColumn());
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= PROGRAMA EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // PROGRAMA ::= DECL PROGRAMA 
            {
              Object RESULT =null;
		System.out.println("PROGRAMA -> DECL PROGRAMA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAMA",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // PROGRAMA ::= PROCEDIMENT PROGRAMA 
            {
              Object RESULT =null;
		System.out.println("PROGRAMA -> PROCEDIMENT PROGRAMA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAMA",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // PROGRAMA ::= MAIN 
            {
              Object RESULT =null;
		System.out.println("PROGRAMA -> MAIN");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAMA",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // DECL ::= DECL_TUPLA PUNTICOMA 
            {
              Object RESULT =null;
		System.out.println("DECL -> DECL TUPLA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // DECL ::= DECL_TIPUS PUNTICOMA 
            {
              Object RESULT =null;
		System.out.println("DECL -> DECL_TIPUS");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // DECL ::= DECL_CONST PUNTICOMA 
            {
              Object RESULT =null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // DECL ::= error PUNTICOMA 
            {
              Object RESULT =null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // MODIF ::= REDEF_TUPLA PUNTICOMA 
            {
              Object RESULT =null;
		System.out.println("MODIF -> REDEF_TUPLA PUNTICOMA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MODIF",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // MODIF ::= MODIF_TIPUS PUNTICOMA 
            {
              Object RESULT =null;
		System.out.println("MODIF -> MODIF_TIPUS PUNTICOMA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MODIF",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // SENTENCIES ::= SENT SENTENCIES 
            {
              Object RESULT =null;
		System.out.println("SENTENCIES -> SENT SENTENCIES");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIES",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // SENTENCIES ::= 
            {
              Object RESULT =null;
		System.out.println("SENTENCIES -> @");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENTENCIES",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // SENT ::= DECL 
            {
              Object RESULT =null;
		System.out.println("SENT -> DECL");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // SENT ::= MODIF 
            {
              Object RESULT =null;
		System.out.println("SENT -> MODIF");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // SENT ::= MENTRE 
            {
              Object RESULT =null;
		System.out.println("SENT -> MENTRE");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // SENT ::= FMENTRE 
            {
              Object RESULT =null;
		System.out.println("SENT -> FMENTRE");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // SENT ::= IF 
            {
              Object RESULT =null;
		System.out.println("SENT -> IF");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // SENT ::= CRIDA_PROC 
            {
              Object RESULT =null;
		System.out.println("SENT -> CRIDA_PROC");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // SENT ::= FOR 
            {
              Object RESULT =null;
		System.out.println("SENT -> FOR");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // SENT ::= ENTRADAS PUNTICOMA 
            {
              Object RESULT =null;
		System.out.println("SENT -> ENTRADAS");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // SENT ::= SORTIDAS PUNTICOMA 
            {
              Object RESULT =null;
		System.out.println("SENT -> SORTIDAS");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SENT",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // PROCEDIMENT ::= metode ID LPAREN ARGS RPAREN LCLAUDAT SENTENCIES RCLAUDAT 
            {
              Object RESULT =null;
		System.out.println("PROC");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROCEDIMENT",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // PROCEDIMENT ::= metode TIPUS ID LPAREN ARGS RPAREN LCLAUDAT SENTENCIES RCLAUDAT RETURN 
            {
              Object RESULT =null;
		System.out.println("PROC");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROCEDIMENT",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // RETURN ::= retorna E 
            {
              Object RESULT =null;
		System.out.println("RETURN -> retorna E");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // CRIDA_PROC ::= ID LPAREN ARGS RPAREN PUNTICOMA 
            {
              Object RESULT =null;
		System.out.println("CRIDA_PROC");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CRIDA_PROC",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // MAIN ::= metode main LPAREN cadena ID LCORCH RCORCH RPAREN LCLAUDAT SENTENCIES RCLAUDAT 
            {
              Object RESULT =null;
		System.out.println("MAIN");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MAIN",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // TIPUS ::= decimal 
            {
              Object RESULT =null;
		System.out.println("TIPUS -> decimal");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TIPUS",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // TIPUS ::= enter 
            {
              Object RESULT =null;
		System.out.println("TIPUS -> enter");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TIPUS",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // TIPUS ::= logic 
            {
              Object RESULT =null;
		System.out.println("TIPUS -> logic");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TIPUS",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // TIPUS ::= cadena 
            {
              Object RESULT =null;
		System.out.println("TIPUS -> cadena");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TIPUS",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // TIPUS ::= caracter 
            {
              Object RESULT =null;
		System.out.println("TIPUS -> caracter");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TIPUS",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // ARGS ::= ARGS_1 
            {
              Object RESULT =null;
		System.out.println("ARGS -> ARGS_1");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARGS",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // ARGS ::= 
            {
              Object RESULT =null;
		System.out.println("@");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARGS",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // ARGS_1 ::= ARG COMA ARGS_1 
            {
              Object RESULT =null;
		System.out.println("ARGS_1 -> ARG COMA ARGS_1");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARGS_1",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // ARGS_1 ::= ARG 
            {
              Object RESULT =null;
		System.out.println("ARGS_1 -> ARG");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARGS_1",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // ARG ::= TIPUS ID 
            {
              Object RESULT =null;
		System.out.println("ARG -> TIPUS ID");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ARG",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // MENTRE ::= mentres LPAREN E RPAREN fer LCLAUDAT SENTENCIES RCLAUDAT 
            {
              Object RESULT =null;
		System.out.println("MENTRE");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MENTRE",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // IF ::= si LPAREN E RPAREN LCLAUDAT SENTENCIES RCLAUDAT IF_1 
            {
              Object RESULT =null;
		System.out.println("IF");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // IF_1 ::= sino si LPAREN E RPAREN LCLAUDAT SENTENCIES RCLAUDAT IF_1 
            {
              Object RESULT =null;
		System.out.println("IF_1");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_1",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // IF_1 ::= sino LCLAUDAT SENTENCIES RCLAUDAT 
            {
              Object RESULT =null;
		System.out.println("IF_1");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_1",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // IF_1 ::= 
            {
              Object RESULT =null;
		System.out.println("@");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF_1",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // FMENTRE ::= fer LCLAUDAT SENTENCIES RCLAUDAT mentres LPAREN L RPAREN PUNTICOMA 
            {
              Object RESULT =null;
		System.out.println("FMENTRE");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FMENTRE",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // FOR ::= per LPAREN TIPUS A PUNTICOMA FOR_1 PUNTICOMA FOR_1 RPAREN LCLAUDAT SENT RCLAUDAT 
            {
              Object RESULT =null;
		System.out.println("FOR");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-11)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // FOR ::= per LPAREN PUNTICOMA FOR_1 PUNTICOMA FOR_1 RPAREN LCLAUDAT SENT RCLAUDAT 
            {
              Object RESULT =null;
		System.out.println("FOR");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-9)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // FOR_1 ::= E 
            {
              Object RESULT =null;
		System.out.println("FOR_1 -> E");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR_1",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // FOR_1 ::= 
            {
              Object RESULT =null;
		System.out.println("FOR_1 -> NULL");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR_1",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // ENTRADAS ::= entradaS LPAREN TIPUS COMA ID RPAREN 
            {
              Object RESULT =null;
		System.out.println("ENTRADAS");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ENTRADAS",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // SORTIDAS ::= sortidaS LPAREN E RPAREN 
            {
              Object RESULT =null;
		System.out.println("SORTIDAS");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SORTIDAS",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // DECL_CONST ::= constant TIPUS A ASSIGN I 
            {
              Object RESULT =null;
		System.out.println("DECL_CONST -> constant TIPUS A ASSIGN I");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL_CONST",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // DECL_CONST ::= constant DECL_TUPLA 
            {
              Object RESULT =null;
		System.out.println("DECL_CONST -> constant DECL_TUPLA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL_CONST",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // DECL_TIPUS ::= TIPUS A 
            {
              Object RESULT =null;
		System.out.println("DECL_TIPUS -> TIPUS A ");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL_TIPUS",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // DECL_TIPUS ::= TIPUS A ASSIGN I 
            {
              Object RESULT =null;
		System.out.println("DECL_TIPUS -> TIPUS A ASSIGN I");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL_TIPUS",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // MODIF_TIPUS ::= ID I_1 
            {
              Object RESULT =null;
		System.out.println("MODIF_TIPUS -> ID I_1");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MODIF_TIPUS",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // A ::= ID COMA A 
            {
              Object RESULT =null;
		System.out.println("A -> ID COMA A");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("A",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // A ::= ID 
            {
              Object RESULT =null;
		System.out.println("A -> ID");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("A",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // I ::= E 
            {
              Object RESULT =null;
		System.out.println("I -> ASSIGN E");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // I ::= MODIF_TIPUS 
            {
              Object RESULT =null;
		System.out.println("ASSIGN MODIF_TIPUS");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // I ::= VAL_TUPLA 
            {
              Object RESULT =null;
		System.out.println("ASSIGN VAL_TUPLA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // I ::= CRIDA_PROC 
            {
              Object RESULT =null;
		System.out.println("ASSIGN CRIDA_PROC");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // I_1 ::= AUTOSUM 
            {
              Object RESULT =null;
		System.out.println("I_1 -> AUTOSUM");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I_1",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // I_1 ::= AUTOSUB 
            {
              Object RESULT =null;
		System.out.println("I_1 -> AUTOSUB");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I_1",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // I_1 ::= SUMAHI E 
            {
              Object RESULT =null;
		System.out.println("I_1 -> SUMAHI E");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I_1",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // I_1 ::= RESTAHI E 
            {
              Object RESULT =null;
		System.out.println("I_1 -> RESTAHI E");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I_1",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // I_1 ::= ASSIGN I 
            {
              Object RESULT =null;
		System.out.println("I_1 -> ASSIGN I");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("I_1",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // VALORS ::= I 
            {
              Object RESULT =null;
		System.out.println("VALORS -> I");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // VALORS ::= I COMA VALORS 
            {
              Object RESULT =null;
		System.out.println("VALORS -> I  COMA VALORS");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VALORS",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // VAL_TUPLA ::= ID LPAREN venter RPAREN 
            {
              Object RESULT =null;
		System.out.println("VAL_TUPLA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VAL_TUPLA",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // DECL_TUPLA ::= tupla ID LPAREN RPAREN NOVA_TUPLA 
            {
              Object RESULT =null;
		System.out.println("DECL_TUPLA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL_TUPLA",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // NOVA_TUPLA ::= ASSIGN LPAREN VALORS RPAREN 
            {
              Object RESULT =null;
		System.out.println("NOVA_TUPLA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NOVA_TUPLA",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // REDEF_TUPLA ::= ID ASSIGN NOVA_TUPLA 
            {
              Object RESULT =null;
		System.out.println("REDEF_TUPLA");
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("REDEF_TUPLA",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // E ::= T E_1 
            {
              SimbolE RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolT t = (SimbolT)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolEp e = (SimbolEp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("E -> T E_1");
    if(errorSemantic){
        RESULT = new SimbolE();
    }else{
        if((e==null)||(e.getTsb()=="ts_nul")){
            RESULT = new SimbolE(t.getTsb(),t.getTipus(),t.getMode(),t.getEsquerre(),t.getDreta());
        }else{
           if(t.getTsb()!="ts_boolea"){
                report_error_semantic("L'operand ha de ser de tipus booleà", t.getEsquerre(),t.getDreta());
                errorSemantic = true;
                RESULT = new SimbolE();
            }else{
                e.setTs_heretat("ts_boolea"); //calcular
                RESULT = new SimbolE("ts_boolea","id_nula","moderesult",t.getEsquerre(),e.getDreta());
            } 
        }
    }
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // E_1 ::= AND T E_1 
            {
              SimbolEp RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolT t = (SimbolT)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolEp e = (SimbolEp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("E_1 -> AND T E_1");
        if(errorSemantic){
            RESULT = new SimbolEp();
        }else{
            if((e==null)||(e.getTsb() == "ts_nul")){ //venim de Ep -> @
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació AND", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.AND,"moderesult",t.getDreta());
                }
            }else{
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació booleana", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    e.setTs_heretat("ts_boolea");
                    //operació
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.AND,"moderesult",e.getDreta());
                }  
            }
        }
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E_1",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // E_1 ::= OR T E_1 
            {
              SimbolEp RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token op = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolT t = (SimbolT)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolEp e = (SimbolEp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("E_1 -> OR T E_1");
        if(errorSemantic){
            RESULT = new SimbolEp();
        }else{
            if((e==null)||(e.getTsb() == "ts_nul")){ //venim de Ep -> @
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació OR", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.OR,"moderesult",t.getDreta());
                }
            }else{
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació booleana", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    e.setTs_heretat("ts_boolea");
                    //operació
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.OR,"moderesult",e.getDreta());
                }  
            }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E_1",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // E_1 ::= 
            {
              SimbolEp RESULT =null;
		System.out.println("E_1 -> @");
        RESULT = new SimbolEp();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E_1",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // T ::= N T_1 
            {
              SimbolT RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolN n = (SimbolN)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolTp t = (SimbolTp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("T -> N T_1");
    if(errorSemantic){
        RESULT = new SimbolT();
    }else{
        if((t==null)||(t.getTsb() == "ts_nul")){ //venim de Tp -> @
            RESULT = new SimbolT(n.getTsb(),n.getTipus(),n.getMode(),n.getEsquerre(),n.getDreta());
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                report_error_semantic("El terminal no es adequat per una operació lògica", n.getEsquerre(),n.getDreta()); //arreglar
                errorSemantic = true;
                RESULT = new SimbolT();
            }else{
                t.setTs_heretat(n.getTsb()); //li afegim per si després hem de fer operacions
                RESULT = new SimbolT("ts_boolea","id_nula","moderesult",n.getEsquerre(),t.getDreta());
            }   
        }
    }

    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("T",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // T_1 ::= IGIG N 
            {
              SimbolTp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolN n = (SimbolN)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("T_1 -> IGIG N T_1");
    if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de comparacio", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.IGIG,"moderesult",n.getDreta());
                    }
        }
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("T_1",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // T_1 ::= DIF N 
            {
              SimbolTp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolN n = (SimbolN)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("T_1 -> DIF N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de DIF", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.DIF,"moderesult",n.getDreta());
                    }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("T_1",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // T_1 ::= MENOR N 
            {
              SimbolTp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolN n = (SimbolN)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("T_1 -> MENOR N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MENOR", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MENORI,"moderesult",n.getDreta());
                    }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("T_1",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // T_1 ::= MAJOR N 
            {
              SimbolTp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolN n = (SimbolN)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("T_1 -> MAJOR N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MAJOR", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MAJOR,"moderesult",n.getDreta());
                    }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("T_1",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // T_1 ::= MENORI N 
            {
              SimbolTp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolN n = (SimbolN)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("T_1 -> MENORI N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MENORI", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MENORI,"moderesult",n.getDreta());
                    }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("T_1",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // T_1 ::= MAJORI N 
            {
              SimbolTp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolN n = (SimbolN)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("T_1 -> MAJORI N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MAJORI", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MAJORI,"moderesult",n.getDreta());
                    }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("T_1",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // T_1 ::= 
            {
              SimbolTp RESULT =null;
		System.out.println("T_1 -> @");
        RESULT = new SimbolTp();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("T_1",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // N ::= M N_1 
            {
              SimbolN RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolM m = (SimbolM)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolNp n = (SimbolNp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("N -> M N_1");
        if(errorSemantic){
            RESULT = new SimbolN();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que M_1 -> @
                RESULT = new SimbolN(m.getTsb(),m.getTipus(),m.getMode(),m.getEsquerre(),m.getDreta()); //pot ser tupla
            }else{ //M_1 ha fet qualque operació, hem de passar el tsb de f

                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                   report_error_semantic("El terminal no té un tipus adequat", m.getEsquerre(),m.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolN(); 
                }else{
                    n.setTs_heretat(m.getTsb());
                    String tsb = n.obtenir_sintetitzat();
                    RESULT = new SimbolN(tsb,"id_nula","moderesult",m.getEsquerre(),n.getDreta());
                }
                
            }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("N",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // N_1 ::= ADD M N_1 
            {
              SimbolNp RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolM m = (SimbolM)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolNp n = (SimbolNp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("N_1 -> ADD M N_1");
        if(errorSemantic){
            RESULT = new SimbolNp();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que N_1 -> @
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de suma", m.getEsquerre(),m.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolNp();
                }else{
                    RESULT = new SimbolNp(m.getTsb(),m.getTipus(),ParserSym.ADD,"moderesult",m.getDreta());
                }
            }else{ // N_1 té tsb i una operació associada
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de suma", m.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolNp();
                    }else{ //assumim que a m.tsb = cadena o decimal o caracter 
                        n.setTs_heretat(m.getTsb());
                        String resultat = n.obtenir_sintetitzat();

                        if(resultat == "ts_nul"){
                            report_error_semantic("No és pot fer una operació amb aquest tipus", m.getEsquerre(),m.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolNp();
                        }else{
                            RESULT = new SimbolNp(resultat,"id_nula",ParserSym.ADD,"moderesult",n.getDreta());
                        }

                    }
            }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("N_1",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // N_1 ::= SUB M N_1 
            {
              SimbolNp RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolM m = (SimbolM)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolNp n = (SimbolNp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("N_1 -> SUB M N_1");
        if(errorSemantic){
            RESULT = new SimbolNp();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que N_1 -> @
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de resta", m.getDreta(),m.getEsquerre());
                    errorSemantic = true;
                    RESULT = new SimbolNp();
                }else{
                    RESULT = new SimbolNp(m.getTsb(),m.getTipus(),ParserSym.ADD,"moderesult",m.getDreta());
                }
            }else{ // N_1 té tsb i una operació associada
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de resta", m.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolNp();
                    }else{ //assumim que a m.tsb = cadena o decimal o caracter 
                        n.setTs_heretat(m.getTsb());
                        String resultat = n.obtenir_sintetitzat();

                        if(resultat == "ts_nul"){
                            report_error_semantic("No es pot fer una operació amb aquest tipus", m.getDreta(),m.getEsquerre());
                            errorSemantic = true;
                            RESULT = new SimbolNp();
                        }else{
                            RESULT = new SimbolNp(resultat,"id_nula",ParserSym.SUB,"moderesult",n.getDreta());
                        }

                    }
            }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("N_1",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // N_1 ::= 
            {
              SimbolNp RESULT =null;
		System.out.println("N_1 -> @");
        RESULT = new SimbolNp();
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("N_1",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // M ::= F M_1 
            {
              SimbolM RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolF f = (SimbolF)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolMp m = (SimbolMp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("M -> F M_1");
        if(errorSemantic){
            RESULT = new SimbolM();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //vol dir que M_1 -> @
                RESULT = new SimbolM(f.getTsb(),f.getTipus(),f.getMode(),f.getEsquerre(),f.getDreta()); //pot ser tupla
            }else{ //M_1 ha fet qualque operació, hem de passar el tsb de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de suma/resta/multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolM();
                }else{
                    //comprovar si f es decimal
                    m.setTs_heretat(f.getTsb());
                    String tsb = m.obtenir_sintetitzat();

                    if(tsb=="ts_nul"){
                        report_error_semantic("no es pot fer el mòdul d'un decimal ", f.getEsquerre(),f.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolM();
                    }else{
                       RESULT = new SimbolM(tsb,"id_nula","moderesult",f.getEsquerre(),m.getDreta()); 
                    }
                }
            }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // M_1 ::= MULT F M_1 
            {
              SimbolMp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token e = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolF f = (SimbolF)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolMp m = (SimbolMp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("M_1 -> MULT F M_1");
        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.MULT,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = cadena o decimal o caracter 
                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    if(resultat == "ts_nul"){
                        report_error_semantic("no es pot fer el mòdul d'un decimal ", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                        RESULT = new SimbolMp(resultat,"id_nula",ParserSym.MULT,"moderesult",m.getDreta());
                    }

                }
            }
        }

        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M_1",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // M_1 ::= DIV F M_1 
            {
              SimbolMp RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token d = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolF f = (SimbolF)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolMp m = (SimbolMp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("M_1 -> DIV F M_1");

        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de divisió", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.DIV,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = cadena o decimal o caracter 
                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    if(resultat == "ts_nul"){
                        report_error_semantic("no es pot fer el mòdul amb un nombre decimal", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                        RESULT = new SimbolMp(resultat,"id_nula",ParserSym.DIV,"moderesult",m.getDreta());
                    }

                }
            }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M_1",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // M_1 ::= MOD F M_1 
            {
              SimbolMp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token e = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolF f = (SimbolF)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SimbolMp m = (SimbolMp)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("M_1 -> MOD F M_1");

        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")||(f.getTsb()=="ts_decimal")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.MOD,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")||(f.getTsb()=="ts_decimal")){
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = enter o caracter

                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    //pensant que resultat tendrà un ts correcte

                    if(resultat == "ts_decimal"){
                        report_error_semantic("No es pot fer el mòdul d'un valor decimal", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                      RESULT = new SimbolMp(resultat,"id_nula",ParserSym.MOD,"moderesult",m.getDreta());  
                    }
                }
            }
        }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M_1",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // M_1 ::= 
            {
              SimbolMp RESULT =null;
		System.out.println("M_1 -> @");
        RESULT = new SimbolMp();
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M_1",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // F ::= LPAREN E RPAREN 
            {
              SimbolF RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token l = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolE e = (SimbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> LPAREN E RPAREN");
                if(errorSemantic){
                    RESULT = new SimbolF();
                }else{
                    if(e.getTsb() == "ts_nul"){ //ho trob error
                        report_error("(E) té tsb null", e);
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",l.esquerre,l.dreta); //no tenc clar es mode
                    }   
                } 
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // F ::= venter 
            {
              SimbolF RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> venter");
                RESULT = new SimbolF("ts_enter","id_nula","modeconst",v.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // F ::= SUB venter 
            {
              SimbolF RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token s = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> SUB venter");
                RESULT = new SimbolF("ts_enter","id_nula","modeconst",s.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // F ::= ADD venter 
            {
              SimbolF RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> ADD venter");
                RESULT = new SimbolF("ts_enter","id_nula","modeconst",a.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // F ::= vdecimal 
            {
              SimbolF RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> vdecimal");
                RESULT = new SimbolF("ts_decimal","id_nula","modeconst",v.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // F ::= ADD vdecimal 
            {
              SimbolF RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> ADD vdecimal");
                RESULT = new SimbolF("ts_decimal","id_nula","modeconst",a.esquerre,a.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // F ::= SUB vdecimal 
            {
              SimbolF RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token s = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> SUB vdecimal");
                RESULT = new SimbolF("ts_decimal","id_nula","modeconst",s.esquerre,s.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // F ::= vcaracter 
            {
              SimbolF RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> vcaracter");
                RESULT = new SimbolF("ts_caracter","id_nula","modeconst",v.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // F ::= ADD vcaracter 
            {
              SimbolF RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token a = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> ADD");
                RESULT = new SimbolF("ts_caracter","id_nula","modeconst",a.esquerre,v.dreta); //assegurar que a car hi posam ts_caracter
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // F ::= SUB vcaracter 
            {
              SimbolF RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token s = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> SUB");
                RESULT = new SimbolF("ts_caracter","id_nula","modeconst",s.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // F ::= vcadena 
            {
              SimbolF RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> vcadena");
                RESULT = new SimbolF("ts_cadena","id_nula","modeconst",v.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // F ::= ID 
            {
              SimbolF RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> ID");
                Descripcio descripcio = taula_simbols.consulta((String)id.valor);
                if(descripcio == null){ //si l'identificador no es troba a la taula de símbols
                    report_error_semantic("Undefined id \""+id.valor+"\"", id.esquerre,id.dreta);
                    errorSemantic = true;
                    RESULT  = new SimbolF();
                }else{ //mirar si accepta tuples
                    if(descripcio instanceof Dvar){
                        Dvar var = (Dvar) descripcio;
                        Dtipus tipus = (Dtipus) taula_simbols.consulta(var.tipus()); //ALERTA EN NO TROBAR
                        RESULT = new SimbolF(tipus.dt().tipus_subjacent(),var.tipus(),"modevar",id.esquerre,id.dreta);
                    }else if(descripcio instanceof Dconst){
                        Dconst cons = (Dconst) descripcio;
                        Dtipus tipus = (Dtipus) taula_simbols.consulta(cons.tipus()); //ALERTA EN NO TROBAR
                        RESULT = new SimbolF(tipus.dt().tipus_subjacent(),cons.tipus(),"modeconst",id.esquerre,id.dreta);
                    }else{
                        report_error_semantic("L'identificador: "+id.valor+" té el tipus erroni per a expresions",id.esquerre,id.dreta);
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }
                }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // F ::= vlogic 
            {
              SimbolF RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> vlogic");
                RESULT = new SimbolF("ts_boolea","id_nula","modeconst",v.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // F ::= SUB LPAREN E RPAREN 
            {
              SimbolF RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Token s = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolE e = (SimbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> SUB LPAREN E RPAREN"); //REVISAR

                if(errorSemantic){ //si s'ha comés un error Semantic a E
                   RESULT  = new SimbolF(); 
                }else{
                    if(e.getTsb() == "ts_nul"){
                        report_error_semantic("No es pot restar l'expresió entre parèntesis", e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else if((e.getTsb() != "ts_enter")&&(e.getTsb() != "ts_decimal")&&(e.getTsb() != "ts_caracter")){
                        report_error_semantic("No es pot restar l'expresió entre parèntesis",e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",s.esquerre,r.dreta);
                    } 
                }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // F ::= NOT vlogic 
            {
              SimbolF RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token v = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> NOT vlogic");
                RESULT = new SimbolF("ts_boolea","id_nula","modeconst",n.esquerre,v.dreta);
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // F ::= NOT ID 
            {
              SimbolF RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> NOT ID");
                Descripcio descripcio = taula_simbols.consulta((String)id.valor);

                if(descripcio == null){ //si l'identificador no es troba a la taula de símbols
                    report_error_semantic("Undefined id \""+(String)id.valor+"\"", id.esquerre,id.dreta);
                    errorSemantic = true;
                    RESULT  = new SimbolF();
                }else{
                    if(descripcio instanceof Dvar){
                        Dvar var = (Dvar) descripcio;
                        Dtipus tipus = (Dtipus) taula_simbols.consulta(var.tipus()); //ALERTA EN NO TROBAR

                        if(tipus.dt().tipus_subjacent()!= "ts_boolea"){
                            report_error_semantic("L'identificador: "+(String)id.valor+" té el tipus erroni per al NOT",id.esquerre,id.dreta);
                            errorSemantic = true;
                            RESULT  = new SimbolF();
                        }else{
                            RESULT = new SimbolF(tipus.dt().tipus_subjacent(),var.tipus(),"modevar",n.esquerre,id.dreta);
                        }
                        
                    }else if(descripcio instanceof Dconst){
                        Dconst cons = (Dconst) descripcio;
                        Dtipus tipus = (Dtipus) taula_simbols.consulta(cons.tipus()); //ALERTA EN NO TROBAR

                        if(tipus.dt().tipus_subjacent()!= "ts_boolea"){
                            report_error_semantic("L'identificador: "+(String)id.valor+" té el tipus erroni per al NOT",id.esquerre,id.dreta);
                            errorSemantic = true;
                            RESULT  = new SimbolF();
                        }else{
                          RESULT = new SimbolF(tipus.dt().tipus_subjacent(),cons.tipus(),"modeconst",n.esquerre,id.dreta); //no sé perquè result  
                        }
                    }else{
                        report_error_semantic("L'identificador: "+(String)id.valor+" té el tipus erroni per al NOT",id.esquerre,id.dreta);
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }
                }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // F ::= NOT LPAREN E RPAREN 
            {
              SimbolF RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Token n = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Token l = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SimbolE e = (SimbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Token r = (Token)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		System.out.println("F -> NOT LPAREN E RPAREN"); //posar error semantic
                if(errorSemantic){ //si a E s'ha comés un error semántic
                    RESULT  = new SimbolF();
                }else{
                    if(e.getTsb() != "ts_boolea"){
                        report_error_semantic("L'expresió no és booleana ",e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",n.esquerre,r.dreta);
                    }   
                }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("F",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
