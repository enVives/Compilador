package Compilador.Sintactic;

import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import Compilador.Lexic.Scanner.Token;

import java.io.PrintStream;
import java.util.HashMap;
import Compilador.TSimbols.Taula;
import Compilador.TSimbols.DT.*;
import Compilador.TSimbols.TD.*;
import Compilador.Sintactic.Simbols.*;
import Compilador.Sintactic.Simbols.SimbolValsTupla.KeyValue;
import java.util.Iterator;
import java.util.Stack;
import java.util.ArrayList;
import Compilador.TSimbols.Dada1;
import Compilador.TSimbols.Dada2;
import Compilador.Sintactic.Simbols.SimbolArgsp.KeyValor;

class Parser;


parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    /**********************************************************************
     *             Creació i Gestió de la Taula de Simbols                *
     **********************************************************************/

    Taula taula_simbols = new Taula();

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    private boolean errorSemantic = false;

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_error("Error sintàctic catastròfic", cur_token);
        done_parsing();        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("de sintaxis", cur_token);
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    public void report_error_semantic(String message,Location left, Location right){
        System.err.println("ERROR "+message+" desde: "+left.getLine()+"/"+left.getColumn()+" fins: "+right.getLine()+"/"+right.getColumn());
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }
:}


/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/


terminal Token ID; //String
terminal Token vdecimal; //double
terminal Token venter; //int
terminal Token vlogic; //boolean
terminal Token vcadena; //string
terminal Token vcaracter; //char

terminal  Token  ADD,SUB,MULT,DIV,MOD;
terminal Token LPAREN,RPAREN;
terminal Token AUTOSUM,AUTOSUB,SUMAHI,RESTAHI,ASSIGN;
terminal DOSPUNTS,PUNTICOMA,INTERROG,LCORCH
    ,RCORCH,LCLAUDAT, RCLAUDAT,PUNT, COMA;

terminal Token DIF, IGIG, MENORI, MAJORI, MENOR, MAJOR, OR, AND , NOT;

terminal decimal,enter,logic,cadena,caracter,tupla,si,sino,seleccio,cas,pdefecte,acaba
    ,mentres,fer,per,metode,retorna,nou,constant,entradaS,sortidaS,main,borra,afegeix;

non terminal PROGRAMA,DECL,PROCEDIMENT,MAIN,DECL_TAULA,MODIF,
    MODIF_TUPLA, REM_TUPLA, AFG_TUPLA, MODIF_TAULA, REDEF_TAULA, REDEF_TUPLA,
    SENTENCIES, MENTRE, IF, SWITCH, FMENTRE, CRIDA_PROC, SENT,VAL_TUPLA,
    L,IF_1,SWITCH_1, I, A_1,NOVA_TAULA, NOVA_TUPLA,
    FOR,FOR_1,OP_CONDICIONAL,OP_CONDICIONAL_1,ENTRADAS,SORTIDAS,DECL_CONST;    

non terminal SimbolF F;
non terminal SimbolE E;
non terminal SimbolEp E_1;
non terminal SimbolT T;
non terminal SimbolTp T_1;
non terminal SimbolN N;
non terminal SimbolNp N_1;
non terminal SimbolM M;
non terminal SimbolMp M_1;
non terminal SimbolR R;
non terminal SimbolValsTupla VALS_TUPLA;
non terminal SimbolValors VALORS;
non terminal SimbolDeclTupla DECL_TUPLA;
non terminal M0;
non terminal PROG;
non terminal SimbolI I_1;
non terminal SimbolA A;
non terminal SimbolDeclTipus DECL_TIPUS ;
non terminal SimbolTipus TIPUS;
non terminal SimbolModifTipus MODIF_TIPUS;
non terminal SimbolArg ARG;
non terminal SimbolArgsp ARGS_1;
non terminal SimbolArgs ARGS;
non terminal SimbolReturn RETURN; 

precedence left  ADD, SUB;
precedence left  MULT, DIV, MOD;

start with PROG;

PROG ::= M0 PROGRAMA {:System.out.println("PROG -> M0 PROGRAMA");:};

PROGRAMA ::= DECL PROGRAMA {:System.out.println("PROGRAMA -> DECL PROGRAMA");:}
            | PROCEDIMENT PROGRAMA {:System.out.println("PROGRAMA -> PROCEDIMENT PROGRAMA");:}
            | MAIN {:System.out.println("PROGRAMA -> MAIN");:}
            ;

M0 ::= {:System.out.println("Inicialització");
        taula_simbols.posar("ent", new Dtipus(new Escalar("ts_enter", Integer.MIN_VALUE, Integer.MAX_VALUE)));
        taula_simbols.posar("decimal", new Dtipus(new Escalar("ts_decimal", (int)Double.MIN_VALUE, (int)Double.MAX_VALUE)));
        taula_simbols.posar("cad", new Dtipus(new DefinicioTipus("ts_cadena")));
        taula_simbols.posar("bool", new Dtipus(new Escalar("ts_boolea", -1, 0)));
        taula_simbols.posar("car", new Dtipus(new Escalar("ts_enter", 0, 255)));
        taula_simbols.posar("tupla", new Dtipus(new Tupla()));
        taula_simbols.posar("VER", new Dconst(-1,"boolea"));
        taula_simbols.posar("FALS", new Dconst(0,"boolea"));
        :};

DECL ::= DECL_TUPLA PUNTICOMA {:System.out.println("DECL -> DECL TUPLA");:} 
        |DECL_TIPUS PUNTICOMA {:System.out.println("DECL -> DECL_TIPUS");:}
        |DECL_CONST PUNTICOMA {::}
        |error PUNTICOMA {::}
        ;
MODIF ::= REDEF_TUPLA PUNTICOMA {:System.out.println("MODIF -> REDEF_TUPLA PUNTICOMA");:}
        | MODIF_TIPUS PUNTICOMA {:System.out.println("MODIF -> MODIF_TIPUS PUNTICOMA");:}
        ;

SENTENCIES ::= SENT SENTENCIES {:System.out.println("SENTENCIES -> SENT SENTENCIES");:}
                | {:System.out.println("SENTENCIES -> @");:}
                ;

SENT ::= DECL {:System.out.println("SENT -> DECL");:}
            |MODIF {:System.out.println("SENT -> MODIF");:}
            |MENTRE {:System.out.println("SENT -> MENTRE");:}
            |FMENTRE {:System.out.println("SENT -> FMENTRE");:}
            |IF {:System.out.println("SENT -> IF");:}
            |CRIDA_PROC PUNTICOMA{:System.out.println("SENT -> CRIDA_PROC");:}
            |FOR {:System.out.println("SENT -> FOR");:}
            |ENTRADAS PUNTICOMA {:System.out.println("SENT -> ENTRADAS");:}
            |SORTIDAS PUNTICOMA {:System.out.println("SENT -> SORTIDAS");:}
            ;

PROCEDIMENT ::= metode ID:i LPAREN ARGS:a RPAREN LCLAUDAT SENTENCIES RCLAUDAT {:System.out.println("PROC");
                    String nom = (String) i.valor;
                    Stack<KeyValor> llista = a.getLlista();

                    taula_simbols.posar(nom, new Dproc());

                    while(!llista.isEmpty()){
                            KeyValor k = llista.pop();
                            String id = k.key; //nom del paràmetre
                            String tipus = k.tipus; //valor o variable a afegir

                            taula_simbols.posarparam(nom,id,new Dvar(tipus));
                            nom += "_"+tipus;
                    }



                :}
                | metode TIPUS:t ID:i LPAREN ARGS:a RPAREN LCLAUDAT SENTENCIES RETURN:r RCLAUDAT {:System.out.println("PROC");
                    Dtipus ti = (Dtipus) taula_simbols.consulta(t.getTipus());
                    if(ti.dt().tipus_subjacent()!=r.getExpresio().getTsb()){
                        report_error_semantic("El tipus de retorn es diferent del procediment", r.getEsquerre(),r.getDreta());
                        errorSemantic = true;
                    }else{
                        String nom = (String) i.valor;
                        Stack<KeyValor> llista = a.getLlista();

                        taula_simbols.posar(nom, new Dproc(t.getTipus()));
    
                        while(!llista.isEmpty()){
                                KeyValor k = llista.pop();
                                String id = k.key; //nom del paràmetre
                                String tipus = k.tipus; //valor o variable a afegir

                                taula_simbols.posarparam(nom,id,new Dvar(tipus));
                                nom += "_"+tipus;
                        }  
                    }
                    
                :}
                ;
RETURN ::= retorna E:e PUNTICOMA {:System.out.println("RETURN -> retorna E");
        RESULT = new SimbolReturn(e,e.getEsquerre(),e.getDreta());
        :};

CRIDA_PROC ::= R:r {:System.out.println("CRIDA_PROC");
            if(!errorSemantic){
                if(r.getMvp() =="procc"){

                }else{
                    report_error_semantic("No es pot posar una referència tota sola", r.getEsquerre(),r.getDreta());
                    errorSemantic = true;
                }        
            }
            
            :}
            |
            ID:i LPAREN RPAREN {:System.out.println("CRIDA_PROC -> ID LPAREN RPAREN");
               Descripcio d = taula_simbols.consulta((String)i.valor);
               if(d!=null){
                    if(!(d instanceof Dproc)){
                        report_error_semantic("L'identificador "+(String)i.valor+" no es un procediment", i.esquerre,i.dreta);
                        errorSemantic = true;
                }
               }else{
                    report_error_semantic("L'identificador "+(String)i.valor+" li falten parametres o no existeix", i.esquerre,i.dreta);
                    errorSemantic = true;
               }
               
            :};

MAIN ::= metode main LPAREN cadena ID LCORCH RCORCH RPAREN LCLAUDAT SENTENCIES RCLAUDAT {:System.out.println("MAIN");:}
        ;

TIPUS ::= decimal {:System.out.println("TIPUS -> decimal");
                RESULT = new SimbolTipus("decimal");
            :}
            |enter {:System.out.println("TIPUS -> enter");
                RESULT = new SimbolTipus("ent");
            :}
            |logic {:System.out.println("TIPUS -> logic");
                RESULT = new SimbolTipus("bool");
                :}
            |cadena{:System.out.println("TIPUS -> cadena");
                RESULT = new SimbolTipus("cad");
                :}
            |caracter {:System.out.println("TIPUS -> caracter");
                RESULT = new SimbolTipus("car");
                :}
            ;

ARGS ::= ARGS_1:a {:System.out.println("ARGS -> ARGS_1");
                RESULT = new SimbolArgs(a.getLlista());
            :}
            | {:System.out.println("@");
                RESULT = new SimbolArgs();
            :}
            ;
ARGS_1 ::= ARG:a COMA ARGS_1:b {:System.out.println("ARGS_1 -> ARG COMA ARGS_1");
                b.afegeix(a.getId(),a.getTipus());
                RESULT = b;
            :}
            | ARG:a {:System.out.println("ARGS_1 -> ARG");
                SimbolArgsp p = new SimbolArgsp();
                p.afegeix(a.getId(),a.getTipus());
                RESULT = p;
            :}
            ;
ARG ::= TIPUS:t ID:d {:System.out.println("ARG -> TIPUS ID");
    RESULT = new SimbolArg((String)d.valor,t.getTipus());
    :};

MENTRE ::= mentres LPAREN E RPAREN fer LCLAUDAT SENTENCIES RCLAUDAT {:System.out.println("MENTRE");:} ;

IF ::=  si LPAREN E RPAREN LCLAUDAT SENTENCIES RCLAUDAT IF_1 {:System.out.println("IF");:};
IF_1 ::= sino si LPAREN E RPAREN LCLAUDAT SENTENCIES RCLAUDAT IF_1 {:System.out.println("IF_1");:}
            | sino LCLAUDAT SENTENCIES RCLAUDAT {:System.out.println("IF_1");:}
            | {:System.out.println("@");:}
            ;
FMENTRE ::= fer LCLAUDAT SENTENCIES RCLAUDAT  mentres LPAREN L RPAREN PUNTICOMA {:System.out.println("FMENTRE");:} ;

FOR ::= per LPAREN TIPUS A PUNTICOMA FOR_1 PUNTICOMA FOR_1 RPAREN LCLAUDAT SENT RCLAUDAT {:System.out.println("FOR");:}
    | per LPAREN PUNTICOMA FOR_1 PUNTICOMA FOR_1 RPAREN LCLAUDAT SENT RCLAUDAT {:System.out.println("FOR");:}
    ;

FOR_1 ::= E {:System.out.println("FOR_1 -> E");:}
    | {:System.out.println("FOR_1 -> NULL");:}
    ;

ENTRADAS ::= entradaS LPAREN TIPUS COMA R RPAREN {:System.out.println("ENTRADAS");:} ;
SORTIDAS ::= sortidaS LPAREN E RPAREN {:System.out.println("SORTIDAS");:};

DECL_CONST ::= constant TIPUS:t A:a ASSIGN E:e  {:System.out.println("DECL_CONST -> constant TIPUS A ASSIGN E");
            if(errorSemantic){
                RESULT = new SimbolDeclTipus();
            }else{
                Dtipus tipus = (Dtipus) taula_simbols.consulta(t.getTipus());
                if(tipus.dt().tipus_subjacent()!=e.getTsb()){
                    report_error_semantic("El tipus de les variables es diferent del valor assignat", a.getEsquerre(),e.getDreta());
                    errorSemantic = true;
                }else{
                    ArrayList<String> llista = a.getLlista();
                    Iterator<String> it = llista.iterator();
                    String ti = t.getTipus(); //tipus que afegirem als identificadors

                    while(it.hasNext()){
                        taula_simbols.posar(it.next(),new Dconst(ti));
                    }
                }
            }
        :}
        | constant TIPUS:t A:a ASSIGN MODIF_TIPUS:m {:System.out.println("DECL_CONST -> constant TIPUS A ASSIGN MODIF_TIPUS");
            if(errorSemantic){
                RESULT = new SimbolDeclTipus();
            }else{
                Dtipus tipus = (Dtipus) taula_simbols.consulta(t.getTipus());

                if(tipus.dt().tipus_subjacent()!=m.getTsb()){
                    report_error_semantic("El tipus de les variables es diferent del valor assignat",a.getEsquerre(),a.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolDeclTipus();
                }else{
                    ArrayList<String> llista = a.getLlista();
                    Iterator<String> it = llista.iterator();
                    String ti = t.getTipus(); //tipus que afegirem als identificadors

                    while(it.hasNext()){
                        taula_simbols.posar(it.next(),new Dconst(ti));
                    }
                }
            }    
        
        :} //una tupla sempre és constant
;

DECL_TIPUS ::= TIPUS:t A:a {:System.out.println("DECL_TIPUS -> TIPUS A ");
            ArrayList<String> llista = a.getLlista();
            Iterator<String> it = llista.iterator();
            String tipus = t.getTipus(); //tipus que afegirem als identificadors

            while(it.hasNext()){
                taula_simbols.posar(it.next(),new Dvar(tipus));
            }
        
        :}
        | TIPUS:t A:a ASSIGN E:e {:System.out.println("DECL_TIPUS -> TIPUS A ASSIGN E");
            if(errorSemantic){
                RESULT = new SimbolDeclTipus();
            }else{
                Dtipus tipus = (Dtipus) taula_simbols.consulta(t.getTipus());
                if(tipus.dt().tipus_subjacent()!=e.getTsb()){
                    report_error_semantic("El tipus de les variables es diferent del valor assignat", a.getEsquerre(),e.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolDeclTipus();
                }else{
                    ArrayList<String> llista = a.getLlista();
                    Iterator<String> it = llista.iterator();
                    String ti = t.getTipus(); //tipus que afegirem als identificadors

                    while(it.hasNext()){
                        taula_simbols.posar(it.next(),new Dvar(ti));
                    }
                }
            }
        :}
        | TIPUS:t A:a ASSIGN MODIF_TIPUS:m {:System.out.println("DECL_TIPUS -> TIPUS A ASSIGN MODIF_TIPUS");
            if(errorSemantic){
                RESULT = new SimbolDeclTipus();
            }else{
                Dtipus tipus = (Dtipus) taula_simbols.consulta(t.getTipus());

                if(tipus.dt().tipus_subjacent()!=m.getTsb()){
                    report_error_semantic("El tipus de les variables es diferent del valor assignat",a.getEsquerre(),a.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolDeclTipus();
                }else{
                    ArrayList<String> llista = a.getLlista();
                    Iterator<String> it = llista.iterator();
                    String ti = t.getTipus(); //tipus que afegirem als identificadors

                    while(it.hasNext()){
                        taula_simbols.posar(it.next(),new Dvar(ti));
                    }
                }
            }
        
        :}
        ;

MODIF_TIPUS ::= R:r I_1:i {:System.out.println("MODIF_TIPUS -> R I_1");
            if(errorSemantic){
                RESULT = new SimbolModifTipus();
            }else{
                if(r.getMvp()=="const"){ //malament
                    report_error_semantic("No es pot modificar una constant", r.getEsquerre(),r.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolModifTipus();
                }else if(r.getMvp()=="procc"){
                    report_error_semantic("No es pot modificar un procediment", r.getEsquerre(),r.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolModifTipus();
                }else{
                    switch(i.getOperacio()){
                    case "as": //cas ++
                        if((r.getTsb()!="ts_enter")&&(r.getTsb()!="ts_decimal")&&(r.getTsb()!="ts_caracter")){
                            report_error_semantic("Tipus equivocat per a la operació ++", r.getEsquerre(),i.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolModifTipus();
                        }else{
                            RESULT = new SimbolModifTipus(r.getTsb(),r.getTipus(),r.getEsquerre(),i.getDreta());
                        }
                        break;
                    case "ar":
                        if((r.getTsb()!="ts_enter")&&(r.getTsb()!="ts_decimal")&&(r.getTsb()!="ts_caracter")){
                            report_error_semantic("Tipus equivocat per a la operació --", r.getEsquerre(),r.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolModifTipus();
                        }else{
                            RESULT = new SimbolModifTipus(r.getTsb(),r.getTipus(),r.getEsquerre(),i.getDreta());
                        }
                        break;
                    case "si":
                        if((i.getTsb()!="ts_enter")&&(i.getTsb()!="ts_caracter")&&(i.getTsb()!="ts_decimal")){
                            report_error_semantic("La Expresió té un tipus equivocat per l'operacio: +=", i.getEsquerre(),i.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolModifTipus();
                        }else{
                            RESULT = new SimbolModifTipus(r.getTsb(),r.getTipus(),r.getEsquerre(),i.getDreta());
                        }
                        break;
                    case "ri":
                        if((i.getTsb()!="ts_enter")&&(i.getTsb()!="ts_caracter")&&(i.getTsb()!="ts_decimal")){
                            report_error_semantic("La Expresió té un tipus equivocat per l'operacio: -=", r.getEsquerre(),i.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolModifTipus();
                        }else{
                            if((r.getTsb()!="ts_enter")&&(r.getTsb()!="ts_caracter")&&(r.getTsb()!="ts_decimal")){
                            report_error_semantic("La Referència te un tipus equivocat per l'operació: +=", r.getEsquerre(),r.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolModifTipus();
                            }else{
                             RESULT = new SimbolModifTipus(r.getTsb(),r.getTipus(),r.getEsquerre(),i.getDreta()); 
                            }
                        }
                        break;
                    case "ig":
                        if(!(i.getTsb().equals(r.getTsb()))){
                            report_error_semantic("El tipus de la referència i la expresió no coincideixen amb l'operacio: =", r.getEsquerre(),i.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolModifTipus();
                        }else{
                            RESULT = new SimbolModifTipus(r.getTsb(),r.getTipus(),r.getEsquerre(),i.getDreta());
                        }
                        break;
                }
                }
                
            }

            :}
            | R:r ASSIGN MODIF_TIPUS:m {:System.out.println("MODIF_TIPUS -> R ASSIGN MODIF_TIPUS");
            if(errorSemantic){
                RESULT = new SimbolModifTipus();
            }else{

                if(!m.getTsb().equals(r.getTsb())){
                    report_error_semantic("El tipus de la referència i la modificacio no coincideixen amb l'operacio: =", r.getEsquerre(),m.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolModifTipus();
                }else{
                    RESULT = new SimbolModifTipus(r.getTsb(),r.getTipus(),r.getEsquerre(),m.getDreta()); 
                }
            }
            
            :}; //R només pot ser id var o constant

//Si R.tsb = ts_record -> referència a tupla
//Si R.tsb = int -> pot venir de id1.id2 on id1.tsb = ts_record

R ::= ID:d {:System.out.println("R -> ID ");
        Descripcio descripcio = taula_simbols.consulta((String)d.valor);
        if(descripcio == null){ //no es troba a la taula de simbols
            report_error_semantic("Undefined id \""+d.valor+"\"", d.esquerre,d.dreta);
            errorSemantic = true;
            RESULT  = new SimbolR();
        }else{ //ja es troba a la taula de simbols.
            if(descripcio instanceof Dvar){ //variable
                Dvar var = (Dvar) descripcio;
                Dtipus tipus = (Dtipus) taula_simbols.consulta(var.tipus()); //ALERTA EN NO TROBAR
                RESULT = new SimbolR((String)d.valor,tipus.dt().tipus_subjacent(),var.tipus(),"var",d.esquerre,d.dreta);
            }else if(descripcio instanceof Dconst){ //variable o tupla
                Dconst c = (Dconst) descripcio;
                Dtipus tipus = (Dtipus) taula_simbols.consulta(c.tipus()); //ALERTA EN NO TROBAR
                RESULT = new SimbolR((String)d.valor,tipus.dt().tipus_subjacent(),c.tipus(),"const",d.esquerre,d.dreta);
                //el tipus pot ser tupla També
                //això es per quan ens interessa ficar una tupla dins una tupla o un subprograma
                //id(a) on 'a' és una tupla.
            }else{ //si no es tracta ni d'una variable, ni d'una constant, error
                report_error_semantic("ID es un procediment \""+d.valor+"\"", d.esquerre,d.dreta);
                errorSemantic = true;
                RESULT  = new SimbolR();
            }
        }
        :} //per identificadors, constants i variables
    //Idea: cercar id a la ts i mirar si es un subprograma
    //agafar els tipus de tots els valors i cercar el nom amb els tipus.
    | ID:id LPAREN VALORS:v RPAREN:r {:System.out.println("R -> ID (VALORS)"); //subprograma
        //1: mirar si id es un subprograma, amb els valors
        //2: comprovar si el subprograma te un tipus subjacent
        //si en té l'afegim a R amb la resta de informació

        ArrayList<SimbolE> llista = v.getLlista(); //llista amb els paràmetres
        if(llista.isEmpty()){ //crida a un subprograma fora paràmetres
           Descripcio descripcio = taula_simbols.consulta((String)id.valor);
           if(descripcio == null){
            report_error_semantic("Undefined id \""+id.valor+"\"", id.esquerre,id.dreta);
            errorSemantic = true;
            RESULT  = new SimbolR();
            }else{
                if(descripcio instanceof Dproc){
                    Dproc proc = (Dproc) descripcio;
                    String tipus = proc.getTipus(); //miram si el procediment té algun tipus de retorn
                    if(tipus == "id_nula"){
                      RESULT = new SimbolR((String)id.valor,"ts_nul","id_nula","procc",id.esquerre,id.dreta);  
                    }else{
                        Descripcio t = taula_simbols.consulta(proc.getTipus());
                        if(t instanceof Dtipus){ //no fa falta crec
                            Dtipus t1 = (Dtipus) t;
                            RESULT = new SimbolR((String)id.valor,t1.dt().tipus_subjacent(),tipus,"procc",id.esquerre,id.dreta); 
                        }else{
                            report_error_semantic("El tipus del subprograma \""+id.valor+"\" es erroni", id.esquerre,id.dreta);
                            errorSemantic = true;
                            RESULT  = new SimbolR();
                        }
                    }
                    
                }else{
                    report_error_semantic("L'ID \""+id.valor+"\" no és un subprograma", id.esquerre,id.dreta);
                    errorSemantic = true;
                    RESULT  = new SimbolR();
                }
            } 
        }else{
            Iterator <SimbolE> it = llista.iterator();
            String nom = (String)id.valor;
            while(it.hasNext()){
                SimbolE e = it.next();
                if(e.getTsb() == "ts_nul"){
                    report_error_semantic("El paràmetre no té el tipus adecuat per un subprograma", e.getEsquerre(),e.getDreta());
                    errorSemantic = true;
                    RESULT  = new SimbolR();
                }else{
                    switch(e.getTsb()){
                        case "ts_boolea":
                                nom += "_"+"bool";
                                break;
                        case "ts_cadena":
                                nom+= "_"+"cad";
                                break;
                        case "ts_decimal":
                                nom+= "_"+"decimal";
                                break;
                        case "ts_enter":
                                nom+= "_"+"ent";
                                break;
                        case "ts_caracter":
                                nom+= "_"+"car";
                                break;
                        case "ts_record":
                                nom+= "_"+"tupla";
                                break;
                    }
                }
            }
            Descripcio descripcio = taula_simbols.consulta(nom);
            if(descripcio == null){
                report_error_semantic("El subprograma amb aquests paràmetres no existeix", id.esquerre,r.dreta);
                errorSemantic = true;
                RESULT  = new SimbolR();
            }else{
                if(descripcio instanceof Dproc){
                    Dproc proc = (Dproc) descripcio;
                    if(proc.getTipus() == "id_nula"){
                        RESULT = new SimbolR(nom,"ts_nul","id_nula","procc",id.esquerre,r.dreta);
                    }else{
                      Dtipus tipus = (Dtipus) taula_simbols.consulta(proc.getTipus()); //alerta
                      RESULT = new SimbolR(nom,tipus.dt().tipus_subjacent(),proc.getTipus(),"procc",id.esquerre,r.dreta); 
                    }
                }else{ //per si acàs
                    report_error_semantic("Id no és un subprograma", id.esquerre,r.dreta);
                    errorSemantic = true;
                    RESULT  = new SimbolR();
                }
            }
        }
        :} //per subprogrames
    | R:r PUNT ID:i {:System.out.println("R -> R PUNT ID "+(String)i.valor);
        if(errorSemantic){
            RESULT  = new SimbolR();
        }else{
            if((r.getMvp()=="const")&&(r.getTsb()=="ts_record")){
                Dcamp c = (Dcamp) taula_simbols.consultacamp(r.getIdb_dreta(),(String)i.valor);
                if(c!=null){
                    Dtipus tipus = (Dtipus) taula_simbols.consulta(c.tipus());
                    if(c.tipus()=="tupla"){
                        RESULT = new SimbolR(r.getIdb(),c.getIdb(),tipus.dt().tipus_subjacent(),c.tipus(),"const",r.getEsquerre(),i.dreta);
                    }else{
                        RESULT = new SimbolR(r.getIdb(),(String)i.valor,tipus.dt().tipus_subjacent(),c.tipus(),"var",r.getEsquerre(),i.dreta);
                    }
                }else{
                    report_error_semantic("Id no es un camp de la tupla: "+r.getIdb_dreta(), i.esquerre,i.dreta);
                    errorSemantic = true;
                    RESULT  = new SimbolR(); 
                }
            }else{
            report_error_semantic("La referència "+r.getIdb_dreta()+" no és una tupla", r.getEsquerre(),r.getDreta());
                errorSemantic = true;
                RESULT  = new SimbolR(); 
            } 
        }
        

    :}; //per tuples

A ::= ID:i COMA A:a {:System.out.println("A -> ID COMA A");
    a.afegir_id((String)i.valor);
    RESULT = new SimbolA(a.getLlista(),i.esquerre,i.dreta);
    :}

    | ID:i {:System.out.println("A -> ID");
    SimbolA simbol = new SimbolA(i.esquerre,i.dreta);
    simbol.afegir_id((String)i.valor);
    RESULT = simbol;
    :}
 ; 

I_1 ::= AUTOSUM:a {:System.out.println("I_1 -> AUTOSUM");
    RESULT = new SimbolI("as","id_nula","ts_nul",a.esquerre,a.dreta);
    :}
    | AUTOSUB:a {:System.out.println("I_1 -> AUTOSUB");
    RESULT = new SimbolI("ar","id_nula","ts_nul",a.esquerre,a.dreta);
    :}
    | SUMAHI:s E:e {:System.out.println("I_1 -> SUMAHI E");
        if(errorSemantic){
        RESULT = new SimbolI();
        }else{
        RESULT = new SimbolI("si",e.getTipus(),e.getTsb(),s.esquerre,e.getDreta());   
        }
    :}
    | RESTAHI:r E:e {:System.out.println("I_1 -> RESTAHI E");
        if(errorSemantic){
            RESULT = new SimbolI();
        }else{
            RESULT = new SimbolI("ri",e.getTipus(),e.getTsb(),r.esquerre,e.getDreta());   
        }
    :}
    | ASSIGN:a E:e  {:System.out.println("I_1 -> ASSIGN E");
        if(errorSemantic){
            RESULT = new SimbolI();
        }else{
            RESULT = new SimbolI("ig",e.getTipus(),e.getTsb(),a.esquerre,e.getDreta());   
        }
    
    :}
    ;

//REVISAR que ens pot arribar per E

VALORS ::= E:e {:System.out.println("VALORS -> E");
        if(errorSemantic){ //error a E
            RESULT = new SimbolValors();
        }else{
            SimbolValors v = new SimbolValors();
            v.afegirE(e); //afegim e
            RESULT = v;
        }
        :}
        | E:e COMA VALORS:v {:System.out.println("VALORS -> E  COMA VALORS");
            if(errorSemantic){
                RESULT = new SimbolValors();
            }else{
                v.afegirE(e); //alreves, hauriem d'agafar la llista, i després ficarli
                RESULT = new SimbolValors(v.getLlista());
            }
            :}
        ;

//una tupla no serà mai buida

VALS_TUPLA ::= E:e COMA VALS_TUPLA:v {:System.out.println("VALS_TUPLA -> E COMA VALS_TUPLA");
                if(errorSemantic){
                    RESULT = new SimbolValsTupla();
                }else{
                    v.afegeix("buit", e);
                    RESULT = new SimbolValsTupla(v.getLlista());
                }
            :}
            | E:e DOSPUNTS ID:d COMA VALS_TUPLA:v {:System.out.println("VALS_TUPLA -> E DOSPUNTS ID COMA VALS_TUPLA");
                if(errorSemantic){
                    RESULT = new SimbolValsTupla();
                }else{
                    v.afegeix((String)d.valor, e);
                    RESULT = new SimbolValsTupla(v.getLlista());
                }
            :}
            | E:e {:System.out.println("VALS_TUPLA -> E");
                if(errorSemantic){
                    RESULT = new SimbolValsTupla();
                }else{
                    SimbolValsTupla sim = new SimbolValsTupla();
                    sim.afegeix("buit", e);
                    RESULT = sim;
                }  
            :}
            | E:e DOSPUNTS ID:d {:System.out.println("VALS_TUPLA -> E DOSPUNTS ID");
                if(errorSemantic){
                    RESULT = new SimbolValsTupla();
                }else{
                    SimbolValsTupla sim = new SimbolValsTupla();
                    sim.afegeix((String) d.valor, e);
                    RESULT = sim;
                }  
                :};

DECL_TUPLA ::= tupla ID:i LPAREN RPAREN ASSIGN LPAREN:r VALS_TUPLA:v RPAREN {:System.out.println("DECL_TUPLA");
                if(errorSemantic){
                    RESULT = new SimbolDeclTupla();
                }else{
                    //Gestió
                    int n =0;
                    Stack<KeyValue> llista = v.getLlista();
                    Boolean bol = taula_simbols.posar((String)i.valor,new Dconst("tupla")); //mirar si posar es true o false
                    if(bol){
                        while(!llista.isEmpty()){
                            KeyValue k = llista.pop();
                            String nom = k.key; //nom del paràmetre
                            SimbolE simbol = k.value; //valor o variable a afegir
                            if(nom == "buit"){ //no té identificador
                                nom = "Item"+n; //nom que li posam als camps que no tenen id
                                n++;
                            }else{
                                n++; 
                            }
                            if(simbol.getTsb()=="ts_record"){
                                bol = taula_simbols.posarcamp((String)i.valor,nom,new Dcamp(simbol.getIdb(),simbol.getTipus(),n,simbol.getTsb()));
                            }else{
                                bol = taula_simbols.posarcamp((String)i.valor,nom,new Dcamp(simbol.getTipus(),n,simbol.getTsb()));
                            }
                            if(bol == false){
                                break;
                            }
                        }
                        //no retornam res encara
                    }else{
                        report_error_semantic("La tupla \""+(String)i.valor+"\" ja existeix", i.esquerre,r.dreta);
                        errorSemantic = true;
                    }
                }

                :}
                
            | tupla ID:i LPAREN RPAREN ASSIGN R:r {:System.out.println("TUPLA -> R"); //revisar
                if(r.getTsb() != "ts_record"){
                    report_error_semantic("A la tupla \""+(String)i.valor+"\" no es pot assignar una referència que no sigui tupla", i.esquerre,r.getDreta());
                    errorSemantic = true;
                }else{
                    Boolean bol = taula_simbols.posar((String)i.valor,new Dconst("tupla")); //mirar si posar es true o false
                    if(bol){
                        String tu = r.getIdb_dreta(); //id de la nostra referència
                        Dada1 d = taula_simbols.consulta_tupla(tu);
                        Descripcio descripcio = d.td();

                        if(descripcio instanceof Dconst){
                            Dada2 first = d.first(); //volem obtenir els elements de R

                            while(first!=null){
                                Dcamp camp = (Dcamp) taula_simbols.consultacamp(tu,first.idcamp());
                                if(camp.getTsb() == "ts_record"){
                                    taula_simbols.posarcamp((String)i.valor,first.idcamp(),new Dcamp(camp.getIdb(),camp.tipus(),camp.getDespl(),camp.getTsb()));
                                }else{
                                    taula_simbols.posarcamp((String)i.valor,first.idcamp(),new Dcamp(camp.tipus(),camp.getDespl(),camp.getTsb()));
                                }
                                first = first.next();
                            }
                        }else{
                           report_error_semantic("La referència "+r.getIdb()+"no es una tupla", i.esquerre,r.getDreta());
                            errorSemantic = true; 
                        }
                    }else{
                        report_error_semantic("La tupla \""+(String)i.valor+"\" ja existeix", i.esquerre,r.getDreta());
                        errorSemantic = true;
                    }
                }
            
            :}; //sempre ha de tenir valors


E ::= T:t E_1:e {:System.out.println("E -> T E_1");
    if(errorSemantic){
        RESULT = new SimbolE();
    }else{
        if((e==null)||(e.getTsb()=="ts_nul")){
            RESULT = new SimbolE(t.getIdb(),t.getTsb(),t.getTipus(),t.getMode(),t.getEsquerre(),t.getDreta());
        }else{
           if(t.getTsb()!="ts_boolea"){
                report_error_semantic("L'operand ha de ser de tipus booleà", t.getEsquerre(),t.getDreta());
                errorSemantic = true;
                RESULT = new SimbolE();
            }else{
                e.setTs_heretat("ts_boolea"); //calcular
                RESULT = new SimbolE("ts_boolea","id_nula","moderesult",t.getEsquerre(),e.getDreta());
            } 
        }
    }
    :};

E_1 ::= AND:op T:t E_1:e {:System.out.println("E_1 -> AND T E_1");
        if(errorSemantic){
            RESULT = new SimbolEp();
        }else{
            if((e==null)||(e.getTsb() == "ts_nul")){ //venim de Ep -> @
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació AND", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.AND,"moderesult",t.getDreta());
                }
            }else{
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació booleana", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    e.setTs_heretat("ts_boolea");
                    //operació
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.AND,"moderesult",e.getDreta());
                }  
            }
        }
    :}
    | OR:op T:t E_1:e {:System.out.println("E_1 -> OR T E_1");
        if(errorSemantic){
            RESULT = new SimbolEp();
        }else{
            if((e==null)||(e.getTsb() == "ts_nul")){ //venim de Ep -> @
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació OR", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.OR,"moderesult",t.getDreta());
                }
            }else{
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació booleana", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    e.setTs_heretat("ts_boolea");
                    //operació
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.OR,"moderesult",e.getDreta());
                }  
            }
        }
        :}
    | {:System.out.println("E_1 -> @");
        RESULT = new SimbolEp();
        :}
    ;

T ::= N:n T_1:t {:System.out.println("T -> N T_1");
    if(errorSemantic){
        RESULT = new SimbolT();
    }else{
        if((t==null)||(t.getTsb() == "ts_nul")){ //venim de Tp -> @
            RESULT = new SimbolT(n.getIdb(),n.getTsb(),n.getTipus(),n.getMode(),n.getEsquerre(),n.getDreta());
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                report_error_semantic("El terminal no es adequat per una operació lògica", n.getEsquerre(),n.getDreta()); //arreglar
                errorSemantic = true;
                RESULT = new SimbolT();
            }else{
                t.setTs_heretat(n.getTsb()); //li afegim per si després hem de fer operacions
                RESULT = new SimbolT("ts_boolea","id_nula","moderesult",n.getEsquerre(),t.getDreta());
            }   
        }
    }

    :};

T_1 ::= IGIG N:n {:System.out.println("T_1 -> IGIG N T_1");
    if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de comparacio", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.IGIG,"moderesult",n.getDreta());
                    }
        }
    :} //hauriem de llevar tp, no volem repetició en aquest cas
    | DIF N:n {:System.out.println("T_1 -> DIF N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de DIF", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.DIF,"moderesult",n.getDreta());
                    }
        }
        :}
    |MENOR N:n {:System.out.println("T_1 -> MENOR N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MENOR", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MENORI,"moderesult",n.getDreta());
                    }
        }
        :}
    |MAJOR N:n {:System.out.println("T_1 -> MAJOR N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MAJOR", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MAJOR,"moderesult",n.getDreta());
                    }
        }
        :}
    |MENORI N:n {:System.out.println("T_1 -> MENORI N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MENORI", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MENORI,"moderesult",n.getDreta());
                    }
        }
        :}
    |MAJORI N:n {:System.out.println("T_1 -> MAJORI N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MAJORI", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MAJORI,"moderesult",n.getDreta());
                    }
        }
        :}
    | {:System.out.println("T_1 -> @");
        RESULT = new SimbolTp();
        :}
;

N ::= M:m N_1:n {:System.out.println("N -> M N_1");
        if(errorSemantic){
            RESULT = new SimbolN();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que M_1 -> @
                RESULT = new SimbolN(m.getIdb(),m.getTsb(),m.getTipus(),m.getMode(),m.getEsquerre(),m.getDreta()); //pot ser tupla
            }else{ //M_1 ha fet qualque operació, hem de passar el tsb de f

                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                   report_error_semantic("El terminal no té un tipus adequat", m.getEsquerre(),m.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolN(); 
                }else{
                    n.setTs_heretat(m.getTsb());
                    String tsb = n.obtenir_sintetitzat();
                    RESULT = new SimbolN(tsb,"id_nula","moderesult",m.getEsquerre(),n.getDreta());
                }
                
            }
        }
        :};

N_1 ::= ADD M:m N_1:n {:System.out.println("N_1 -> ADD M N_1");
        if(errorSemantic){
            RESULT = new SimbolNp();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que N_1 -> @
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de suma", m.getEsquerre(),m.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolNp();
                }else{
                    RESULT = new SimbolNp(m.getTsb(),m.getTipus(),ParserSym.ADD,"moderesult",m.getDreta());
                }
            }else{ // N_1 té tsb i una operació associada
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de suma", m.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolNp();
                    }else{ //assumim que a m.tsb = cadena o decimal o caracter 
                        n.setTs_heretat(m.getTsb());
                        String resultat = n.obtenir_sintetitzat();

                        if(resultat == "ts_nul"){
                            report_error_semantic("No és pot fer una operació amb aquest tipus", m.getEsquerre(),m.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolNp();
                        }else{
                            RESULT = new SimbolNp(resultat,"id_nula",ParserSym.ADD,"moderesult",n.getDreta());
                        }

                    }
            }
        }
        :}
    | SUB M:m N_1:n {:System.out.println("N_1 -> SUB M N_1");
        if(errorSemantic){
            RESULT = new SimbolNp();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que N_1 -> @
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de resta", m.getDreta(),m.getEsquerre());
                    errorSemantic = true;
                    RESULT = new SimbolNp();
                }else{
                    RESULT = new SimbolNp(m.getTsb(),m.getTipus(),ParserSym.ADD,"moderesult",m.getDreta());
                }
            }else{ // N_1 té tsb i una operació associada
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de resta", m.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolNp();
                    }else{ //assumim que a m.tsb = cadena o decimal o caracter 
                        n.setTs_heretat(m.getTsb());
                        String resultat = n.obtenir_sintetitzat();

                        if(resultat == "ts_nul"){
                            report_error_semantic("No es pot fer una operació amb aquest tipus", m.getDreta(),m.getEsquerre());
                            errorSemantic = true;
                            RESULT = new SimbolNp();
                        }else{
                            RESULT = new SimbolNp(resultat,"id_nula",ParserSym.SUB,"moderesult",n.getDreta());
                        }

                    }
            }
        }
        :}
    | {:System.out.println("N_1 -> @");
        RESULT = new SimbolNp();
        :}
    ;

M ::= F:f M_1:m {:System.out.println("M -> F M_1");
        if(errorSemantic){
            RESULT = new SimbolM();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //vol dir que M_1 -> @
                RESULT = new SimbolM(f.getIdb(),f.getTsb(),f.getTipus(),f.getMode(),f.getEsquerre(),f.getDreta()); //pot ser tupla
            }else{ //M_1 ha fet qualque operació, hem de passar el tsb de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de suma/resta/multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolM();
                }else{
                    //comprovar si f es decimal
                    m.setTs_heretat(f.getTsb());
                    String tsb = m.obtenir_sintetitzat();

                    if(tsb=="ts_nul"){
                        report_error_semantic("no es pot fer el mòdul d'un decimal ", f.getEsquerre(),f.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolM();
                    }else{
                       RESULT = new SimbolM(tsb,"id_nula","moderesult",f.getEsquerre(),m.getDreta()); 
                    }
                }
            }
        }
        :};

M_1 ::= MULT:e F:f M_1:m {:System.out.println("M_1 -> MULT F M_1");
        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.MULT,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = cadena o decimal o caracter 
                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    if(resultat == "ts_nul"){
                        report_error_semantic("no es pot fer el mòdul d'un decimal ", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                        RESULT = new SimbolMp(resultat,"id_nula",ParserSym.MULT,"moderesult",m.getDreta());
                    }

                }
            }
        }

        :}

    | DIV:d F:f M_1:m {:System.out.println("M_1 -> DIV F M_1");

        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de divisió", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.DIV,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = cadena o decimal o caracter 
                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    if(resultat == "ts_nul"){
                        report_error_semantic("no es pot fer el mòdul amb un nombre decimal", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                        RESULT = new SimbolMp(resultat,"id_nula",ParserSym.DIV,"moderesult",m.getDreta());
                    }

                }
            }
        }
        :}

    | MOD:e F:f M_1:m {:System.out.println("M_1 -> MOD F M_1");

        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")||(f.getTsb()=="ts_decimal")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.MOD,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")||(f.getTsb()=="ts_decimal")){
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = enter o caracter

                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    //pensant que resultat tendrà un ts correcte

                    if(resultat == "ts_decimal"){
                        report_error_semantic("No es pot fer el mòdul d'un valor decimal", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                      RESULT = new SimbolMp(resultat,"id_nula",ParserSym.MOD,"moderesult",m.getDreta());  
                    }
                }
            }
        }
        :}
    | {:System.out.println("M_1 -> @");
        RESULT = new SimbolMp();
    :}
    ;

//canviar simbolF, afegir-hi posició primera i darrera

F ::= LPAREN:l E:e RPAREN:r {:System.out.println("F -> LPAREN E RPAREN");
                if(errorSemantic){
                    RESULT = new SimbolF();
                }else{
                    if(e.getTsb() == "ts_nul"){ //ho trob error
                        report_error("(E) té tsb null", e);
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",l.esquerre,l.dreta); //no tenc clar es mode
                    }   
                } 
                    :}

    | venter:v {:System.out.println("F -> venter");
                RESULT = new SimbolF("ts_enter","ent","modeconst",v.esquerre,v.dreta);
                :} 
    | SUB:s venter:v {:System.out.println("F -> SUB venter");
                RESULT = new SimbolF("ts_enter","ent","modeconst",s.esquerre,v.dreta);
                :}
    | ADD:a venter:v {:System.out.println("F -> ADD venter");
                RESULT = new SimbolF("ts_enter","ent","modeconst",a.esquerre,v.dreta);
                :}
    | vdecimal:v {:System.out.println("F -> vdecimal");
                RESULT = new SimbolF("ts_decimal","decimal","modeconst",v.esquerre,v.dreta);
                :}
    | ADD:a vdecimal:v {:System.out.println("F -> ADD vdecimal");
                RESULT = new SimbolF("ts_decimal","decimal","modeconst",a.esquerre,a.dreta);
                :}
    | SUB:s vdecimal:v {:System.out.println("F -> SUB vdecimal");
                RESULT = new SimbolF("ts_decimal","decimal","modeconst",s.esquerre,s.dreta);
                :}
    | vcaracter:v {:System.out.println("F -> vcaracter");
                RESULT = new SimbolF("ts_caracter","car","modeconst",v.esquerre,v.dreta);
                :}
    | ADD:a vcaracter:v {:System.out.println("F -> ADD");
                RESULT = new SimbolF("ts_caracter","car","modeconst",a.esquerre,v.dreta); //assegurar que a car hi posam ts_caracter
                :}
    | SUB:s vcaracter:v {:System.out.println("F -> SUB");
                RESULT = new SimbolF("ts_caracter","car","modeconst",s.esquerre,v.dreta);
                :}
    | vcadena:v {:System.out.println("F -> vcadena");
                RESULT = new SimbolF("ts_cadena","cad","modeconst",v.esquerre,v.dreta);
                :}
    | R: r {:System.out.println("F -> ID");
                if(errorSemantic){
                    RESULT  = new SimbolF(); 
                }else{
                    if(r.getTsb() == "ts_nul"){ //error
                        report_error_semantic("La referència "+r.getIdb()+" te tipus subjacent nul",r.getEsquerre(),r.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        if(r.getMvp() == "var"){
                            RESULT = new SimbolF(r.getTsb(),r.getTipus(),"modevar",r.getEsquerre(),r.getDreta());
                        }else if((r.getMvp() == "const")||(r.getMvp() == "procc")){
                            RESULT = new SimbolF(r.getIdb(),r.getTsb(),r.getTipus(),"modeconst",r.getEsquerre(),r.getDreta());
                        }
                    }  
                }
                :}
    | SUB:s R:r {:System.out.println("F -> SUB R");
                if(errorSemantic){
                    RESULT  = new SimbolF(); 
                }else{
                    if(r.getTsb() == "ts_nul"){ //error
                        report_error_semantic("La referència "+r.getIdb()+" te tipus subjacent nul",s.esquerre,r.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        if(r.getMvp() == "var"){
                            RESULT = new SimbolF(r.getTsb(),r.getTipus(),"modevar",r.getEsquerre(),r.getDreta());
                        }else if((r.getMvp() == "const")||(r.getMvp() == "procc")){
                            RESULT = new SimbolF(r.getTsb(),r.getTipus(),"modeconst",r.getEsquerre(),r.getDreta());
                        }
                    }  
                }
                :}

    | ADD:a R:r {:System.out.println("F -> ADD R");
                if(errorSemantic){
                    RESULT  = new SimbolF(); 
                }else{
                    if(r.getTsb() == "ts_nul"){ //error
                        report_error_semantic("La referència "+r.getIdb()+" te tipus subjacent nul",a.esquerre,r.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        if(r.getMvp() == "var"){
                            RESULT = new SimbolF(r.getTsb(),r.getTipus(),"modevar",r.getEsquerre(),r.getDreta());
                        }else if((r.getMvp() == "const")||(r.getMvp() == "procc")){
                            RESULT = new SimbolF(r.getTsb(),r.getTipus(),"modeconst",r.getEsquerre(),r.getDreta());
                        }
                    }  
                }
                :}
    | vlogic:v {:System.out.println("F -> vlogic");
                RESULT = new SimbolF("ts_boolea","bool","modeconst",v.esquerre,v.dreta);
                :} 
    | SUB:s LPAREN E:e RPAREN:r {:System.out.println("F -> SUB LPAREN E RPAREN"); //REVISAR

                if(errorSemantic){ //si s'ha comés un error Semantic a E
                   RESULT  = new SimbolF(); 
                }else{
                    if(e.getTsb() == "ts_nul"){
                        report_error_semantic("No es pot restar l'expresió entre parèntesis", e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else if((e.getTsb() != "ts_enter")&&(e.getTsb() != "ts_decimal")&&(e.getTsb() != "ts_caracter")){
                        report_error_semantic("No es pot restar l'expresió entre parèntesis",e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",s.esquerre,r.dreta);
                    } 
                }
                :}
    | NOT:n vlogic:v {:System.out.println("F -> NOT vlogic");
                RESULT = new SimbolF("ts_boolea","bool","modeconst",n.esquerre,v.dreta);
                :}
    | NOT:n R:r {:System.out.println("F -> NOT ID");
                if(errorSemantic){
                    RESULT  = new SimbolF(); 
                }else{
                    if(r.getTsb() == "ts_nul"){ //error
                        report_error_semantic("La referència "+r.getIdb()+" te tipus subjacent nul",r.getEsquerre(),r.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        if(r.getMvp() == "var"){
                            if(r.getTsb() != "ts_boolea"){
                                report_error_semantic("La referència "+r.getIdb()+" no té tsb booleà", n.esquerre,r.getDreta());
                                errorSemantic = true;
                                RESULT  = new SimbolF();
                            }else{
                              RESULT = new SimbolF(r.getTsb(),r.getTipus(),"modevar",r.getEsquerre(),r.getDreta());  
                            }
                            
                        }else if(r.getMvp() == "const"){
                            if(r.getTsb() != "ts_boolea"){
                                report_error_semantic("La referència "+r.getIdb()+" no té tsb booleà", n.esquerre,r.getDreta());
                                errorSemantic = true;
                             RESULT  = new SimbolF();
                            }else{
                              RESULT = new SimbolF(r.getTsb(),r.getTipus(),"modeconst",r.getEsquerre(),r.getDreta());  
                            }
                        }
                    }  
                }
                :}
    | NOT:n LPAREN:l E:e RPAREN:r {:System.out.println("F -> NOT LPAREN E RPAREN"); //posar error semantic
                if(errorSemantic){ //si a E s'ha comés un error semántic
                    RESULT  = new SimbolF();
                }else{
                    if(e.getTsb() != "ts_boolea"){
                        report_error_semantic("L'expresió no és booleana ",e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",n.esquerre,r.dreta);
                    }   
                }
                :}
    ;