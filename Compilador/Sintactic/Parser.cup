package Compilador.Sintactic;

import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import Compilador.Lexic.Scanner.Token;

import java.io.PrintStream;
import java.util.HashMap;
import Compilador.TSimbols.Taula;
import Compilador.TSimbols.DT.*;
import Compilador.TSimbols.TD.*;
import Compilador.Sintactic.Simbols.*;

class Parser;


parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) { 
        this.scanner = scanner;
    }
***/
    /**********************************************************************
     *             Creació i Gestió de la Taula de Simbols                *
     **********************************************************************/

    Taula taula_simbols = new Taula();

    /**********************************************************************
     * sobrecàrrega de mètodes per gestionar els errors que es localitzin *
     **********************************************************************/

    private boolean errorSemantic = false;

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_error("Error sintàctic catastròfic", cur_token);
        done_parsing();        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("de sintaxis", cur_token);
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder msg = new StringBuilder("ERROR");
        if (info instanceof Symbol) {
            ComplexSymbol token = (ComplexSymbol)info;
            Location l = token.getLeft();
            
            if (l != null) {
                msg.append(" (fila: ")
                   .append(l.getLine())
                   .append(", columna: ")
                   .append(l.getColumn())
                   .append(")");
            }
        }
        msg.append(": ").append(message);
        
        System.err.println(msg);
    }

    public void report_error_semantic(String message,Location left, Location right){
        System.err.println("ERROR "+message+" desde: "+left.getLine()+"/"+left.getColumn()+" fins: "+right.getLine()+"/"+right.getColumn());
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Error catastròfic ("+message+")", info);
        done_parsing();
    }
:}


/**
 ** També aquí es poden afegir accions a realitzar quan es requereix un token.
scan with {:     next_token(); :}
**/


terminal Token ID; //String
terminal Token vdecimal; //double
terminal Token venter; //int
terminal Token vlogic; //boolean
terminal Token vcadena; //string
terminal Token vcaracter; //char

terminal  Token  ADD,SUB,MULT,DIV,MOD;
terminal Token LPAREN,RPAREN;
terminal ASSIGN,AUTOSUM,AUTOSUB,SUMAHI,RESTAHI,DOSPUNTS,PUNTICOMA,INTERROG,LCORCH
    ,RCORCH,LCLAUDAT, RCLAUDAT,PUNT, COMA;

terminal Token DIF, IGIG, MENORI, MAJORI, MENOR, MAJOR, OR, AND , NOT;

terminal decimal,enter,logic,cadena,caracter,tupla,si,sino,seleccio,cas,pdefecte,acaba
    ,mentres,fer,per,metode,retorna,nou,constant,entradaS,sortidaS,main,borra,afegeix;

non terminal PROGRAMA,DECL,PROCEDIMENT,MAIN,DECL_TUPLA,DECL_TAULA,DECL_TIPUS,MODIF,
    MODIF_TUPLA, REM_TUPLA, AFG_TUPLA, MODIF_TAULA, REDEF_TAULA, REDEF_TUPLA, MODIF_TIPUS,
    SENTENCIES, MENTRE, IF, SWITCH, FMENTRE, ARGS, TIPUS, RETURN, CRIDA_PROC, ARGS_1, SENT,VAL_TUPLA,
    ARG,L,IF_1,SWITCH_1, I, I_1, A, A_1,NOVA_TAULA, NOVA_TUPLA,
    VALORS,FOR,FOR_1,OP_CONDICIONAL,OP_CONDICIONAL_1,ENTRADAS,SORTIDAS,DECL_CONST;    

non terminal SimbolF F;
non terminal SimbolE E;
non terminal SimbolEp E_1;
non terminal SimbolT T;
non terminal SimbolTp T_1;
non terminal SimbolN N;
non terminal SimbolNp N_1;
non terminal SimbolM M;
non terminal SimbolMp M_1;

precedence left  ADD, SUB;
precedence left  MULT, DIV, MOD;

start with PROGRAMA;

PROGRAMA ::= DECL PROGRAMA {:System.out.println("PROGRAMA -> DECL PROGRAMA");:}
            | PROCEDIMENT PROGRAMA {:System.out.println("PROGRAMA -> PROCEDIMENT PROGRAMA");:}
            | MAIN {:System.out.println("PROGRAMA -> MAIN");:}
            ;

DECL ::= DECL_TUPLA PUNTICOMA {:System.out.println("DECL -> DECL TUPLA");:} 
        |DECL_TIPUS PUNTICOMA {:System.out.println("DECL -> DECL_TIPUS");:}
        |DECL_CONST PUNTICOMA {::}
        |error PUNTICOMA {::}
        ;
MODIF ::= REDEF_TUPLA PUNTICOMA {:System.out.println("MODIF -> REDEF_TUPLA PUNTICOMA");:}
        | MODIF_TIPUS PUNTICOMA {:System.out.println("MODIF -> MODIF_TIPUS PUNTICOMA");:}
        ;

SENTENCIES ::= SENT SENTENCIES {:System.out.println("SENTENCIES -> SENT SENTENCIES");:}
                | {:System.out.println("SENTENCIES -> @");:}
                ;

SENT ::= DECL {:System.out.println("SENT -> DECL");:}
            |MODIF {:System.out.println("SENT -> MODIF");:}
            |MENTRE {:System.out.println("SENT -> MENTRE");:}
            |FMENTRE {:System.out.println("SENT -> FMENTRE");:}
            |IF {:System.out.println("SENT -> IF");:}
            //|SWITCH {:System.out.println("SENT -> SWITCH");:} de moment no
            |CRIDA_PROC{:System.out.println("SENT -> CRIDA_PROC");:}
            |FOR {:System.out.println("SENT -> FOR");:}
            //|OP_CONDICIONAL PUNTICOMA{:System.out.println("SENT -> OP_CONDICIONAL");:}
            |ENTRADAS PUNTICOMA {:System.out.println("SENT -> ENTRADAS");:}
            |SORTIDAS PUNTICOMA {:System.out.println("SENT -> SORTIDAS");:}
            ;

PROCEDIMENT ::= metode ID LPAREN ARGS RPAREN LCLAUDAT SENTENCIES RCLAUDAT {:System.out.println("PROC");:}
                | metode TIPUS ID LPAREN ARGS RPAREN LCLAUDAT SENTENCIES RCLAUDAT RETURN {:System.out.println("PROC");:}
                ;
RETURN ::= retorna E {:System.out.println("RETURN -> retorna E");:};

CRIDA_PROC ::= ID LPAREN ARGS RPAREN PUNTICOMA {:System.out.println("CRIDA_PROC");:};

MAIN ::= metode main LPAREN cadena ID LCORCH RCORCH RPAREN LCLAUDAT SENTENCIES RCLAUDAT {:System.out.println("MAIN");:}
        ;

TIPUS ::= decimal {:System.out.println("TIPUS -> decimal");:}
            |enter {:System.out.println("TIPUS -> enter");:}
            |logic {:System.out.println("TIPUS -> logic");:}
            |cadena{:System.out.println("TIPUS -> cadena");:}
            |caracter {:System.out.println("TIPUS -> caracter");:}
            ;

ARGS ::= ARGS_1 {:System.out.println("ARGS -> ARGS_1");:}
            | {:System.out.println("@");:}
            ;
ARGS_1 ::= ARG COMA ARGS_1 {:System.out.println("ARGS_1 -> ARG COMA ARGS_1");:}
            | ARG {:System.out.println("ARGS_1 -> ARG");:}
            ;
ARG ::= TIPUS ID {:System.out.println("ARG -> TIPUS ID");:};

MENTRE ::= mentres LPAREN E RPAREN fer LCLAUDAT SENTENCIES RCLAUDAT {:System.out.println("MENTRE");:} ;

IF ::=  si LPAREN E RPAREN LCLAUDAT SENTENCIES RCLAUDAT IF_1 {:System.out.println("IF");:};
IF_1 ::= sino si LPAREN E RPAREN LCLAUDAT SENTENCIES RCLAUDAT IF_1 {:System.out.println("IF_1");:}
            | sino LCLAUDAT SENTENCIES RCLAUDAT {:System.out.println("IF_1");:}
            | {:System.out.println("@");:}
            ;
FMENTRE ::= fer LCLAUDAT SENTENCIES RCLAUDAT  mentres LPAREN L RPAREN PUNTICOMA {:System.out.println("FMENTRE");:} ;

FOR ::= per LPAREN TIPUS A PUNTICOMA FOR_1 PUNTICOMA FOR_1 RPAREN LCLAUDAT SENT RCLAUDAT {:System.out.println("FOR");:}
    | per LPAREN PUNTICOMA FOR_1 PUNTICOMA FOR_1 RPAREN LCLAUDAT SENT RCLAUDAT {:System.out.println("FOR");:}
    ;

FOR_1 ::= E {:System.out.println("FOR_1 -> E");:}
    | {:System.out.println("FOR_1 -> NULL");:}
    ;

/*OP_CONDICIONAL ::= LCLAUDAT E RCLAUDAT INTERROG OP_CONDICIONAL_1 DOSPUNTS OP_CONDICIONAL_1 {:System.out.println("OP_CONDICIONAL");:}
            ;

OP_CONDICIONAL_1 ::= OP_CONDICIONAL {:System.out.println("OP_CONDICIONAL_1 -> OP_CONDICIONAL");:}
            | E {:System.out.println("OP_CONDICIONAL_1 -> E");:}
            ;*/

ENTRADAS ::= entradaS LPAREN TIPUS COMA ID RPAREN {:System.out.println("ENTRADAS");:} ;
SORTIDAS ::= sortidaS LPAREN E RPAREN {:System.out.println("SORTIDAS");:};

/*
SWITCH ::= seleccio LPAREN E RPAREN LCLAUDAT SWITCH_1 RCLAUDAT {:System.out.println("SWITCH");:}
        ;
SWITCH_1 ::= cas E DOSPUNTS SENTENCIES acaba PUNTICOMA SWITCH_1 {:System.out.println("SWITCH_1");:}
        | pdefecte DOSPUNTS SENTENCIES acaba PUNTICOMA {:System.out.println("SWITCH_1");:}
        | {:System.out.println("@");:}
        ;*/
DECL_CONST ::= constant DECL_TIPUS {:System.out.println("DECL_CONST -> constant DECL_TIPUS");:};

DECL_TIPUS ::= TIPUS A {:System.out.println("DECL_TIPUS -> TIPUS A ");:}
        | TIPUS A_1 {:System.out.println("DECL_TIPUS -> TIPUS A_1");:}
        ;
MODIF_TIPUS ::= ID I_1 {:System.out.println("MODIF_TIPUS -> ID I_1");:};


A ::= A_1 I {:System.out.println("A");:};
A_1 ::= ID COMA A_1 {:System.out.println("A_1 -> ID COMA A_1");:}
    | ID {:System.out.println("A_1 -> ID");:}
    ;

I ::= ASSIGN E {:System.out.println("I -> ASSIGN E");:}
    | ASSIGN MODIF_TIPUS {:System.out.println("ASSIGN MODIF_TIPUS");:}
    | ASSIGN VAL_TUPLA {:System.out.println("ASSIGN VAL_TUPLA");:}
    ;

I_1 ::= AUTOSUM {:System.out.println("I_1 -> AUTOSUM");:}
    | AUTOSUB {:System.out.println("I_1 -> AUTOSUB");:}
    | SUMAHI E {:System.out.println("I_1 -> SUMAHI E");:}
    | RESTAHI E {:System.out.println("I_1 -> RESTAHI E");:}
    | I  {:System.out.println("I_1 -> I");:}
    ;

VALORS ::= E {:System.out.println("VALORS -> E");:}
        | E COMA VALORS {:System.out.println("VALORS -> E  COMA VALORS");:}
        ;
VAL_TUPLA ::= ID LPAREN venter RPAREN {:System.out.println("VAL_TUPLA");:};

DECL_TUPLA ::= tupla ID LPAREN RPAREN NOVA_TUPLA {:System.out.println("DECL_TUPLA");:}
            | tupla ID LPAREN RPAREN {:System.out.println("DECL_TUPLA");:}
            ;
NOVA_TUPLA ::= ASSIGN LPAREN VALORS RPAREN {:System.out.println("NOVA_TUPLA");:};

REDEF_TUPLA ::= ID ASSIGN NOVA_TUPLA {:System.out.println("REDEF_TUPLA");:};


E ::= T:t E_1:e {:System.out.println("E -> T E_1");
    if(errorSemantic){
        RESULT = new SimbolE();
    }else{
        if((e==null)||(e.getTsb()=="ts_nul")){
            RESULT = new SimbolE(t.getTsb(),t.getTipus(),t.getMode(),t.getEsquerre(),t.getDreta());
        }else{
           if(t.getTsb()!="ts_boolea"){
                report_error_semantic("L'operand ha de ser de tipus booleà", t.getEsquerre(),t.getDreta());
                errorSemantic = true;
                RESULT = new SimbolE();
            }else{
                e.setTs_heretat("ts_boolea"); //calcular
                RESULT = new SimbolE("ts_boolea","id_nula","moderesult",t.getEsquerre(),e.getDreta());
            } 
        }
    }
    :};

E_1 ::= AND:op T:t E_1:e {:System.out.println("E_1 -> AND T E_1");
        if(errorSemantic){
            RESULT = new SimbolEp();
        }else{
            if((e==null)||(e.getTsb() == "ts_nul")){ //venim de Ep -> @
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació AND", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.AND,"moderesult",t.getDreta());
                }
            }else{
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació booleana", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    e.setTs_heretat("ts_boolea");
                    //operació
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.AND,"moderesult",e.getDreta());
                }  
            }
        }
    :}
    | OR:op T:t E_1:e {:System.out.println("E_1 -> OR T E_1");
        if(errorSemantic){
            RESULT = new SimbolEp();
        }else{
            if((e==null)||(e.getTsb() == "ts_nul")){ //venim de Ep -> @
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació OR", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.OR,"moderesult",t.getDreta());
                }
            }else{
                if(t.getTsb() != "ts_boolea"){ //error, no podem operar amb valors que no son booleans
                    report_error_semantic("L'operand ha de ser de tipus booleà per una operació booleana", t.getEsquerre(),t.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolEp();
                }else{ 
                    e.setTs_heretat("ts_boolea");
                    //operació
                    RESULT = new SimbolEp("ts_boolea","id_nula",ParserSym.OR,"moderesult",e.getDreta());
                }  
            }
        }
        :}
    | {:System.out.println("E_1 -> @");
        RESULT = new SimbolEp();
        :}
    ;

T ::= N:n T_1:t {:System.out.println("T -> N T_1");
    if(errorSemantic){
        RESULT = new SimbolT();
    }else{
        if((t==null)||(t.getTsb() == "ts_nul")){ //venim de Tp -> @
            RESULT = new SimbolT(n.getTsb(),n.getTipus(),n.getMode(),n.getEsquerre(),n.getDreta());
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                report_error_semantic("El terminal no es adequat per una operació lògica", n.getEsquerre(),n.getDreta()); //arreglar
                errorSemantic = true;
                RESULT = new SimbolT();
            }else{
                t.setTs_heretat(n.getTsb()); //li afegim per si després hem de fer operacions
                RESULT = new SimbolT("ts_boolea","id_nula","moderesult",n.getEsquerre(),t.getDreta());
            }   
        }
    }

    :};

T_1 ::= IGIG N:n {:System.out.println("T_1 -> IGIG N T_1");
    if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de comparacio", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.IGIG,"moderesult",n.getDreta());
                    }
        }
    :} //hauriem de llevar tp, no volem repetició en aquest cas
    | DIF N:n {:System.out.println("T_1 -> DIF N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de DIF", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.DIF,"moderesult",n.getDreta());
                    }
        }
        :}
    |MENOR N:n {:System.out.println("T_1 -> MENOR N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MENOR", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MENORI,"moderesult",n.getDreta());
                    }
        }
        :}
    |MAJOR N:n {:System.out.println("T_1 -> MAJOR N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MAJOR", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MAJOR,"moderesult",n.getDreta());
                    }
        }
        :}
    |MENORI N:n {:System.out.println("T_1 -> MENORI N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MENORI", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MENORI,"moderesult",n.getDreta());
                    }
        }
        :}
    |MAJORI N:n {:System.out.println("T_1 -> MAJORI N ");
        if(errorSemantic){
            RESULT = new SimbolTp();
        }else{
            if((n.getTsb() == "ts_nul")||(n.getTsb() == "ts_cadena")||(n.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de MAJORI", n.getEsquerre(),n.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolTp();
                    }else{ //assumim que a n.tsb = decimal o caracter 
                        RESULT = new SimbolTp(n.getTsb(),n.getTipus(),ParserSym.MAJORI,"moderesult",n.getDreta());
                    }
        }
        :}
    | {:System.out.println("T_1 -> @");
        RESULT = new SimbolTp();
        :}
;

N ::= M:m N_1:n {:System.out.println("N -> M N_1");
        if(errorSemantic){
            RESULT = new SimbolN();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que M_1 -> @
                RESULT = new SimbolN(m.getTsb(),m.getTipus(),m.getMode(),m.getEsquerre(),m.getDreta()); //pot ser tupla
            }else{ //M_1 ha fet qualque operació, hem de passar el tsb de f

                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                   report_error_semantic("El terminal no té un tipus adequat", m.getEsquerre(),m.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolN(); 
                }else{
                    n.setTs_heretat(m.getTsb());
                    String tsb = n.obtenir_sintetitzat();
                    RESULT = new SimbolN(tsb,"id_nula","moderesult",m.getEsquerre(),n.getDreta());
                }
                
            }
        }
        :};

N_1 ::= ADD M:m N_1:n {:System.out.println("N_1 -> ADD M N_1");
        if(errorSemantic){
            RESULT = new SimbolNp();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que N_1 -> @
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de suma", m.getEsquerre(),m.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolNp();
                }else{
                    RESULT = new SimbolNp(m.getTsb(),m.getTipus(),ParserSym.ADD,"moderesult",m.getDreta());
                }
            }else{ // N_1 té tsb i una operació associada
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de suma", m.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolNp();
                    }else{ //assumim que a m.tsb = cadena o decimal o caracter 
                        n.setTs_heretat(m.getTsb());
                        String resultat = n.obtenir_sintetitzat();

                        if(resultat == "ts_nul"){
                            report_error_semantic("No és pot fer una operació amb aquest tipus", m.getEsquerre(),m.getDreta());
                            errorSemantic = true;
                            RESULT = new SimbolNp();
                        }else{
                            RESULT = new SimbolNp(resultat,"id_nula",ParserSym.ADD,"moderesult",n.getDreta());
                        }

                    }
            }
        }
        :}
    | SUB M:m N_1:n {:System.out.println("N_1 -> SUB M N_1");
        if(errorSemantic){
            RESULT = new SimbolNp();
        }else{
            if((n==null)||(n.getTsb()=="ts_nul")){ //vol dir que N_1 -> @
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de resta", m.getDreta(),m.getEsquerre());
                    errorSemantic = true;
                    RESULT = new SimbolNp();
                }else{
                    RESULT = new SimbolNp(m.getTsb(),m.getTipus(),ParserSym.ADD,"moderesult",m.getDreta());
                }
            }else{ // N_1 té tsb i una operació associada
                if((m.getTsb() == "ts_nul")||(m.getTsb() == "ts_cadena")||(m.getTsb()=="ts_boolea")){
                        report_error_semantic("El terminal no es adequat per una operació de resta", m.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolNp();
                    }else{ //assumim que a m.tsb = cadena o decimal o caracter 
                        n.setTs_heretat(m.getTsb());
                        String resultat = n.obtenir_sintetitzat();

                        if(resultat == "ts_nul"){
                            report_error_semantic("No es pot fer una operació amb aquest tipus", m.getDreta(),m.getEsquerre());
                            errorSemantic = true;
                            RESULT = new SimbolNp();
                        }else{
                            RESULT = new SimbolNp(resultat,"id_nula",ParserSym.SUB,"moderesult",n.getDreta());
                        }

                    }
            }
        }
        :}
    | {:System.out.println("N_1 -> @");
        RESULT = new SimbolNp();
        :}
    ;

M ::= F:f M_1:m {:System.out.println("M -> F M_1");
        if(errorSemantic){
            RESULT = new SimbolM();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //vol dir que M_1 -> @
                RESULT = new SimbolM(f.getTsb(),f.getTipus(),f.getMode(),f.getEsquerre(),f.getDreta()); //pot ser tupla
            }else{ //M_1 ha fet qualque operació, hem de passar el tsb de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de suma/resta/multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolM();
                }else{
                    //comprovar si f es decimal
                    m.setTs_heretat(f.getTsb());
                    String tsb = m.obtenir_sintetitzat();

                    if(tsb=="ts_nul"){
                        report_error_semantic("no es pot fer el mòdul d'un decimal ", f.getEsquerre(),f.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolM();
                    }else{
                       RESULT = new SimbolM(tsb,"id_nula","moderesult",f.getEsquerre(),m.getDreta()); 
                    }
                }
            }
        }
        :};

M_1 ::= MULT:e F:f M_1:m {:System.out.println("M_1 -> MULT F M_1");
        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.MULT,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de multiplicació", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = cadena o decimal o caracter 
                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    if(resultat == "ts_nul"){
                        report_error_semantic("no es pot fer el mòdul d'un decimal ", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                        RESULT = new SimbolMp(resultat,"id_nula",ParserSym.MULT,"moderesult",m.getDreta());
                    }

                }
            }
        }

        :}

    | DIV:d F:f M_1:m {:System.out.println("M_1 -> DIV F M_1");

        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de divisió", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.DIV,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")){
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = cadena o decimal o caracter 
                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    if(resultat == "ts_nul"){
                        report_error_semantic("no es pot fer el mòdul amb un nombre decimal", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                        RESULT = new SimbolMp(resultat,"id_nula",ParserSym.DIV,"moderesult",m.getDreta());
                    }

                }
            }
        }
        :}

    | MOD:e F:f M_1:m {:System.out.println("M_1 -> MOD F M_1");

        if(errorSemantic){
            RESULT = new SimbolMp();
        }else{
            if((m==null)||(m.getTsb() == "ts_nul")){ //la producció M_1 -> @, comprovar el tipus de f

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")||(f.getTsb()=="ts_decimal")){ //es tracta d'un tsb que no volem per operacions, error
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{
                    RESULT = new SimbolMp(f.getTsb(),f.getTipus(),ParserSym.MOD,"moderesult",f.getDreta());
                }
            }else{ //M_1 té tipus subjacent i operació

                if((f.getTsb() == "ts_nul")||(f.getTsb() == "ts_cadena")||(f.getTsb()=="ts_boolea")||(f.getTsb()=="ts_decimal")){
                    report_error_semantic("El terminal no es adequat per una operació de mòdul", f.getEsquerre(),f.getDreta());
                    errorSemantic = true;
                    RESULT = new SimbolMp();
                }else{ //assumim que a f.tsb = enter o caracter

                    m.setTs_heretat(f.getTsb());
                    String resultat = m.obtenir_sintetitzat();

                    //pensant que resultat tendrà un ts correcte

                    if(resultat == "ts_decimal"){
                        report_error_semantic("No es pot fer el mòdul d'un valor decimal", f.getEsquerre(),m.getDreta());
                        errorSemantic = true;
                        RESULT = new SimbolMp();
                    }else{
                      RESULT = new SimbolMp(resultat,"id_nula",ParserSym.MOD,"moderesult",m.getDreta());  
                    }
                }
            }
        }
        :}
    | {:System.out.println("M_1 -> @");
        RESULT = new SimbolMp();
    :}
    ;

//canviar simbolF, afegir-hi posició primera i darrera

F ::= LPAREN:l E:e RPAREN:r {:System.out.println("F -> LPAREN E RPAREN");
                if(errorSemantic){
                    RESULT = new SimbolF();
                }else{
                    if(e.getTsb() == "ts_nul"){ //ho trob error
                        report_error("(E) té tsb null", e);
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",l.esquerre,l.dreta); //no tenc clar es mode
                    }   
                } 
                    :}

    | venter:v {:System.out.println("F -> venter");
                RESULT = new SimbolF("ts_enter","id_nula","modeconst",v.esquerre,v.dreta);
                :} 
    | SUB:s venter:v {:System.out.println("F -> SUB venter");
                RESULT = new SimbolF("ts_enter","id_nula","modeconst",s.esquerre,v.dreta);
                :}
    | ADD:a venter:v {:System.out.println("F -> ADD venter");
                RESULT = new SimbolF("ts_enter","id_nula","modeconst",a.esquerre,v.dreta);
                :}
    | vdecimal:v {:System.out.println("F -> vdecimal");
                RESULT = new SimbolF("ts_decimal","id_nula","modeconst",v.esquerre,v.dreta);
                :}
    | ADD:a vdecimal:v {:System.out.println("F -> ADD vdecimal");
                RESULT = new SimbolF("ts_decimal","id_nula","modeconst",a.esquerre,a.dreta);
                :}
    | SUB:s vdecimal:v {:System.out.println("F -> SUB vdecimal");
                RESULT = new SimbolF("ts_decimal","id_nula","modeconst",s.esquerre,s.dreta);
                :}
    | vcaracter:v {:System.out.println("F -> vcaracter");
                RESULT = new SimbolF("ts_caracter","id_nula","modeconst",v.esquerre,v.dreta);
                :}
    | ADD:a vcaracter:v {:System.out.println("F -> ADD");
                RESULT = new SimbolF("ts_caracter","id_nula","modeconst",a.esquerre,v.dreta); //assegurar que a car hi posam ts_caracter
                :}
    | SUB:s vcaracter:v {:System.out.println("F -> SUB");
                RESULT = new SimbolF("ts_caracter","id_nula","modeconst",s.esquerre,v.dreta);
                :}
    | vcadena:v {:System.out.println("F -> vcadena");
                RESULT = new SimbolF("ts_cadena","id_nula","modeconst",v.esquerre,v.dreta);
                :}
    | ID: id {:System.out.println("F -> ID");
                Descripcio descripcio = taula_simbols.consulta((String)id.valor);
                if(descripcio == null){ //si l'identificador no es troba a la taula de símbols
                    report_error_semantic("Undefined id \""+id.valor+"\"", id.esquerre,id.dreta);
                    errorSemantic = true;
                    RESULT  = new SimbolF();
                }else{ //mirar si accepta tuples
                    if(descripcio instanceof Dvar){
                        Dvar var = (Dvar) descripcio;
                        Dtipus tipus = (Dtipus) taula_simbols.consulta(var.tipus()); //ALERTA EN NO TROBAR
                        RESULT = new SimbolF(tipus.dt().tipus_subjacent(),var.tipus(),"modevar",id.esquerre,id.dreta);
                    }else if(descripcio instanceof Dconst){
                        Dconst cons = (Dconst) descripcio;
                        Dtipus tipus = (Dtipus) taula_simbols.consulta(cons.tipus()); //ALERTA EN NO TROBAR
                        RESULT = new SimbolF(tipus.dt().tipus_subjacent(),cons.tipus(),"modeconst",id.esquerre,id.dreta);
                    }else{
                        report_error_semantic("L'identificador: "+id.valor+" té el tipus erroni per a expresions",id.esquerre,id.dreta);
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }
                }
                :}
    | vlogic:v {:System.out.println("F -> vlogic");
                RESULT = new SimbolF("ts_boolea","id_nula","modeconst",v.esquerre,v.dreta);
                :} 
    | SUB:s LPAREN E:e RPAREN:r {:System.out.println("F -> SUB LPAREN E RPAREN"); //REVISAR

                if(errorSemantic){ //si s'ha comés un error Semantic a E
                   RESULT  = new SimbolF(); 
                }else{
                    if(e.getTsb() == "ts_nul"){
                        report_error_semantic("No es pot restar l'expresió entre parèntesis", e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else if((e.getTsb() != "ts_enter")&&(e.getTsb() != "ts_decimal")&&(e.getTsb() != "ts_caracter")){
                        report_error_semantic("No es pot restar l'expresió entre parèntesis",e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",s.esquerre,r.dreta);
                    } 
                }
                :}
    | NOT:n vlogic:v {:System.out.println("F -> NOT vlogic");
                RESULT = new SimbolF("ts_boolea","id_nula","modeconst",n.esquerre,v.dreta);
                :}
    | NOT:n ID:id {:System.out.println("F -> NOT ID");
                Descripcio descripcio = taula_simbols.consulta((String)id.valor);

                if(descripcio == null){ //si l'identificador no es troba a la taula de símbols
                    report_error_semantic("Undefined id \""+(String)id.valor+"\"", id.esquerre,id.dreta);
                    errorSemantic = true;
                    RESULT  = new SimbolF();
                }else{
                    if(descripcio instanceof Dvar){
                        Dvar var = (Dvar) descripcio;
                        Dtipus tipus = (Dtipus) taula_simbols.consulta(var.tipus()); //ALERTA EN NO TROBAR

                        if(tipus.dt().tipus_subjacent()!= "ts_boolea"){
                            report_error_semantic("L'identificador: "+(String)id.valor+" té el tipus erroni per al NOT",id.esquerre,id.dreta);
                            errorSemantic = true;
                            RESULT  = new SimbolF();
                        }else{
                            RESULT = new SimbolF(tipus.dt().tipus_subjacent(),var.tipus(),"modevar",n.esquerre,id.dreta);
                        }
                        
                    }else if(descripcio instanceof Dconst){
                        Dconst cons = (Dconst) descripcio;
                        Dtipus tipus = (Dtipus) taula_simbols.consulta(cons.tipus()); //ALERTA EN NO TROBAR

                        if(tipus.dt().tipus_subjacent()!= "ts_boolea"){
                            report_error_semantic("L'identificador: "+(String)id.valor+" té el tipus erroni per al NOT",id.esquerre,id.dreta);
                            errorSemantic = true;
                            RESULT  = new SimbolF();
                        }else{
                          RESULT = new SimbolF(tipus.dt().tipus_subjacent(),cons.tipus(),"modeconst",n.esquerre,id.dreta); //no sé perquè result  
                        }
                    }else{
                        report_error_semantic("L'identificador: "+(String)id.valor+" té el tipus erroni per al NOT",id.esquerre,id.dreta);
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }
                }
                :}
    | NOT:n LPAREN:l E:e RPAREN:r {:System.out.println("F -> NOT LPAREN E RPAREN"); //posar error semantic
                if(errorSemantic){ //si a E s'ha comés un error semántic
                    RESULT  = new SimbolF();
                }else{
                    if(e.getTsb() != "ts_boolea"){
                        report_error_semantic("L'expresió no és booleana ",e.getEsquerre(),e.getDreta());
                        errorSemantic = true;
                        RESULT  = new SimbolF();
                    }else{
                        RESULT = new SimbolF(e.getTsb(),e.getTipus(),"moderesult",n.esquerre,r.dreta);
                    }   
                }
                :}
    ;